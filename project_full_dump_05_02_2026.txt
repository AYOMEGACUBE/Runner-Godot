PROJECT FULL DUMP: 2026-02-05T20:42:30.6751232+03:00

=== PROJECT TREE (ASCII) ===

Godot/    (res://)
├── android/    (res://android)
│   ├── build/    (res://android/build)
│   │   ├── templates/    (res://android/build/templates)
│   │   │   ├── android_debug.apk    (other)
│   │   │   ├── android_release.apk    (other)
│   │   │   ├── android_source.zip    (other)
│   │   │   ├── icudt_godot.dat    (other)
│   │   │   ├── ios.zip    (other)
│   │   │   ├── linux_debug.arm32    (other)
│   │   │   ├── linux_debug.arm64    (other)
│   │   │   ├── linux_debug.x86_32    (other)
│   │   │   ├── linux_debug.x86_64    (other)
│   │   │   ├── linux_release.arm32    (other)
│   │   │   ├── linux_release.arm64    (other)
│   │   │   ├── linux_release.x86_32    (other)
│   │   │   ├── linux_release.x86_64    (other)
│   │   │   ├── macos.zip    (other)
│   │   │   ├── version.txt    (other)
│   │   │   ├── visionos.zip    (other)
│   │   │   ├── web_debug.zip    (other)
│   │   │   ├── web_dlink_debug.zip    (other)
│   │   │   ├── web_dlink_nothreads_debug.zip    (other)
│   │   │   ├── web_dlink_nothreads_release.zip    (other)
│   │   │   ├── web_dlink_release.zip    (other)
│   │   │   ├── web_nothreads_debug.zip    (other)
│   │   │   ├── web_nothreads_release.zip    (other)
│   │   │   ├── web_release.zip    (other)
│   │   │   ├── windows_debug_arm64.exe    (other)
│   │   │   ├── windows_debug_arm64_console.exe    (other)
│   │   │   ├── windows_debug_x86_32.exe    (other)
│   │   │   ├── windows_debug_x86_32_console.exe    (other)
│   │   │   ├── windows_debug_x86_64.exe    (other)
│   │   │   ├── windows_debug_x86_64_console.exe    (other)
│   │   │   ├── windows_release_arm64.exe    (other)
│   │   │   ├── windows_release_arm64_console.exe    (other)
│   │   │   ├── windows_release_x86_32.exe    (other)
│   │   │   ├── windows_release_x86_32_console.exe    (other)
│   │   │   ├── windows_release_x86_64.exe    (other)
│   │   │   └── windows_release_x86_64_console.exe    (other)
│   │   └── .gdignore    (other)
│   └── .build_version    (other)
├── heroes/    (res://heroes)
│   ├── hero_blue.png    (other)
│   ├── hero_blue.png.import    (other)
│   ├── hero_blue_frames.png    (other)
│   ├── hero_blue_frames.png.import    (other)
│   ├── hero_blue_jump_frames.tres    (other)
│   ├── hero_default.png    (other)
│   ├── hero_default.png.import    (other)
│   ├── hero_default_frames.png    (other)
│   ├── hero_default_frames.png.import    (other)
│   ├── hero_default_jump_frames.tres    (other)
│   ├── hero_monster.png    (other)
│   ├── hero_monster.png.import    (other)
│   ├── hero_monster_frames.png    (other)
│   ├── hero_monster_frames.png.import    (other)
│   ├── hero_monster_jump_frames.tres    (other)
│   ├── hero_orange.png    (other)
│   ├── hero_orange.png.import    (other)
│   ├── hero_orange_frames.png    (other)
│   ├── hero_orange_frames.png.import    (other)
│   ├── hero_orange_jump_frames.tres    (other)
│   ├── hero_red.png    (other)
│   ├── hero_red.png.import    (other)
│   ├── hero_red_frames.png    (other)
│   ├── hero_red_frames.png.import    (other)
│   └── hero_red_jump_frames.tres    (other)
├── scripts/    (res://scripts)
│   ├── Level.gd    (gd)
│   ├── Level.gd.uid    (other)
│   ├── Platform.gd    (gd)
│   ├── Platform.gd.uid    (other)
│   ├── Player.gd    (gd)
│   └── Player.gd.uid    (other)
├── wall/    (res://wall)
│   ├── data/    (res://wall/data)
│   │   ├── WallData.gd    (gd)
│   │   └── WallData.gd.uid    (other)
│   ├── segment/    (res://wall/segment)
│   │   ├── WallSegment.gd    (gd)
│   │   ├── WallSegment.gd.uid    (other)
│   │   └── WallSegment.tscn    (tscn)
│   │       ├── WallSegment (Node2D)
│   │       ├── Sprite2D (Sprite2D)
│   │       └── Area2D (Area2D)
│   ├── textures/    (res://wall/textures)
│   │   ├── wall_segment.png    (other)
│   │   └── wall_segment.png.import    (other)
│   ├── wall.gd    (gd)
│   ├── wall.gd.uid    (other)
│   └── wall.tscn    (tscn)
├── .gitattributes    (other)
├── .gitignore    (other)
├── all_files_list.txt    (other)
├── Champions.gd    (gd)
├── Champions.gd.uid    (other)
├── Champions.tscn    (tscn)
│   ├── Champions (Control)
│   └── CenterContainer (CenterContainer)
├── Coin.gd    (gd)
├── Coin.gd.uid    (other)
├── Coin.tscn    (tscn)
│   ├── Coin (Area2D)
│   └── CollisionShape2D (CollisionShape2D)
├── export_presets.cfg    (other)
├── GameState.gd    (gd)
├── GameState.gd.uid    (other)
├── HUD.gd    (gd)
├── HUD.gd.uid    (other)
├── icon.svg    (other)
├── icon.svg.import    (other)
├── level.tscn    (tscn)
│   ├── Level (Node2D)
│   ├── Platforms (Node2D)
│   ├── Player (CharacterBody2D)
│   │   ├── Camera2D (Camera2D)
│   │   ├── CollisionShape2D (CollisionShape2D)
│   │   ├── AnimatedSprite2D (AnimatedSprite2D)
│   │   └── CustomAvatarSprite (Sprite2D)
│   └── HUDLayer (CanvasLayer)
├── MainMenu.gd    (gd)
├── MainMenu.gd.uid    (other)
├── MainMenu.tscn    (tscn)
│   ├── MainMenu (Control)
│   ├── CenterContainer (CenterContainer)
│   └── WarnDialog (AcceptDialog)
├── Platform.tscn    (tscn)
│   ├── Platform (StaticBody2D)
│   └── CollisionShape2D (CollisionShape2D)
├── Profile.gd    (gd)
├── Profile.gd.uid    (other)
├── Profile.tscn    (tscn)
│   ├── Profile (Control)
│   ├── CenterContainer (CenterContainer)
│   ├── FileDialogJumpUp (FileDialog)
│   ├── FileDialogJumpDown (FileDialog)
│   └── WarnDialog (AcceptDialog)
├── project.godot    (other)
├── project_dump_errors.log    (other)
├── project_full_dump_05_02_2026.txt    (other)
└── README.txt    (other)

=== SCENE TREES (ASCII) ===


--- SCENE: res://Champions.tscn ---

├── Champions (Control)
└── CenterContainer (CenterContainer)

--- SCENE: res://Coin.tscn ---

├── Coin (Area2D)
└── CollisionShape2D (CollisionShape2D)

--- SCENE: res://level.tscn ---

├── Level (Node2D)
├── Platforms (Node2D)
├── Player (CharacterBody2D)
│   ├── Camera2D (Camera2D)
│   ├── CollisionShape2D (CollisionShape2D)
│   ├── AnimatedSprite2D (AnimatedSprite2D)
│   └── CustomAvatarSprite (Sprite2D)
└── HUDLayer (CanvasLayer)

--- SCENE: res://MainMenu.tscn ---

├── MainMenu (Control)
├── CenterContainer (CenterContainer)
└── WarnDialog (AcceptDialog)

--- SCENE: res://Platform.tscn ---

├── Platform (StaticBody2D)
└── CollisionShape2D (CollisionShape2D)

--- SCENE: res://Profile.tscn ---

├── Profile (Control)
├── CenterContainer (CenterContainer)
├── FileDialogJumpUp (FileDialog)
├── FileDialogJumpDown (FileDialog)
└── WarnDialog (AcceptDialog)

--- SCENE: res://wall/segment/WallSegment.tscn ---

├── WallSegment (Node2D)
├── Sprite2D (Sprite2D)
└── Area2D (Area2D)

--- SCENE: res://wall/wall.tscn ---


=== SELF-VALIDATION: SCENE STRUCTURE VERIFICATION ===

res://Champions.tscn : 8 node(s) total
  - Champions (Control)
  - CenterContainer (CenterContainer)
    - Panel (Panel)
      - VBoxContainer (VBoxContainer)
        - TitleLabel (Label)
        - ScrollContainer (ScrollContainer)
          - List (VBoxContainer)
        - BackButton (Button)
res://Coin.tscn : 2 node(s) total
  - Coin (Area2D)
  - CollisionShape2D (CollisionShape2D)
res://level.tscn : 13 node(s) total
  - Level (Node2D)
  - Platforms (Node2D)
  - Player (CharacterBody2D)
    - Camera2D (Camera2D)
    - CollisionShape2D (CollisionShape2D)
    - AnimatedSprite2D (AnimatedSprite2D)
    - CustomAvatarSprite (Sprite2D)
  - HUDLayer (CanvasLayer)
    - HUD (Control)
      - VBoxContainer (VBoxContainer)
        - NameLabel (Label)
        - ScoreLabel (Label)
      - BackButton (Button)
res://MainMenu.tscn : 12 node(s) total
  - MainMenu (Control)
  - CenterContainer (CenterContainer)
    - Panel (Panel)
      - VBoxContainer (VBoxContainer)
        - TitleLabel (Label)
        - NicknameLabel (Label)
        - AvatarPreview (TextureRect)
        - PlayButton (Button)
        - ChampionsButton (Button)
        - ProfileButton (Button)
        - GoogleButton (Button)
  - WarnDialog (AcceptDialog)
res://Platform.tscn : 2 node(s) total
  - Platform (StaticBody2D)
  - CollisionShape2D (CollisionShape2D)
res://Profile.tscn : 21 node(s) total
  - Profile (Control)
  - CenterContainer (CenterContainer)
    - Panel (Panel)
      - VBoxContainer (VBoxContainer)
        - TitleLabel (Label)
        - NicknameEdit (LineEdit)
        - HeroSelector (HBoxContainer)
          - HeroLeftButton (Button)
          - HeroPreview (TextureRect)
          - HeroRightButton (Button)
          - HeroNameLabel (Label)
        - CustomAvatarRow (VBoxContainer)
          - CustomAvatarCheck (CheckBox)
          - UploadJumpUpButton (Button)
          - UploadJumpDownButton (Button)
        - ButtonsRow (HBoxContainer)
          - SaveButton (Button)
          - BackButton (Button)
  - FileDialogJumpUp (FileDialog)
  - FileDialogJumpDown (FileDialog)
  - WarnDialog (AcceptDialog)
res://wall/segment/WallSegment.tscn : 4 node(s) total
  - WallSegment (Node2D)
  - Sprite2D (Sprite2D)
  - Area2D (Area2D)
    - CollisionShape2D (CollisionShape2D)
res://wall/wall.tscn : 1 node(s) total
  - Wall (Node2D)

--- VALIDATION ISSUES ---
INFO: res://wall/wall.tscn has only 1 node (might be correct for simple scenes)

=== FILES (.gd and .tscn) ===


--- FILE: D:\YandexDisk\Projects\Runner\Godot\Champions.gd ---

extends Control
# ============================================================================
# Champions.gd — отдельная сцена таблицы чемпионов
# ----------------------------------------------------------------------------
# Требования:
# - отдельный экран
# - корректная сортировка (GameState уже сортирует по score desc)
# - кнопка Back возвращает в MainMenu
# ============================================================================

@export_file("*.tscn")
var main_menu_scene: String = "res://MainMenu.tscn"

@onready var list_box: VBoxContainer = $CenterContainer/Panel/VBoxContainer/ScrollContainer/List
@onready var back_button: Button = $CenterContainer/Panel/VBoxContainer/BackButton
@onready var title_label: Label = $CenterContainer/Panel/VBoxContainer/TitleLabel

func _ready() -> void:
	if title_label:
		title_label.text = "Champions"

	if back_button and not back_button.pressed.is_connected(_on_back_pressed):
		back_button.pressed.connect(_on_back_pressed)

	_refresh()

func _refresh() -> void:
	if list_box == null:
		return

	for c in list_box.get_children():
		c.queue_free()

	var champs: Array = GameState.get_champions()
	if champs.is_empty():
		var lbl := Label.new()
		lbl.text = "Пока пусто"
		lbl.horizontal_alignment = HORIZONTAL_ALIGNMENT_LEFT
		list_box.add_child(lbl)
		return

	for i in range(champs.size()):
		var e = champs[i]
		var place := i + 1
		var n := "???"
		var s := 0
		if typeof(e) == TYPE_DICTIONARY:
			n = str(e.get("name", "???"))
			s = int(e.get("score", 0))

		var lbl2 := Label.new()
		lbl2.text = str(place) + ". " + n + " — " + str(s)
		lbl2.horizontal_alignment = HORIZONTAL_ALIGNMENT_LEFT
		list_box.add_child(lbl2)

func _on_back_pressed() -> void:
	var err := get_tree().change_scene_to_file(main_menu_scene)
	if err != OK:
		push_error("Champions.gd: не удалось вернуться в меню: " + main_menu_scene)


--- FILE: D:\YandexDisk\Projects\Runner\Godot\Champions.tscn ---

[gd_scene load_steps=2 format=3 uid="uid://pnkpfmiog8kr"]

[ext_resource type="Script" uid="uid://x4f0dpsn3ien" path="res://Champions.gd" id="1_champions"]

[node name="Champions" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_champions")

[node name="CenterContainer" type="CenterContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="Panel" type="Panel" parent="CenterContainer"]
custom_minimum_size = Vector2(800, 520)
layout_mode = 2

[node name="VBoxContainer" type="VBoxContainer" parent="CenterContainer/Panel"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 24.0
offset_top = 24.0
offset_right = -24.0
offset_bottom = -24.0
grow_horizontal = 2
grow_vertical = 2

[node name="TitleLabel" type="Label" parent="CenterContainer/Panel/VBoxContainer"]
layout_mode = 2
theme_override_font_sizes/font_size = 32
text = "Champions"

[node name="ScrollContainer" type="ScrollContainer" parent="CenterContainer/Panel/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 3

[node name="List" type="VBoxContainer" parent="CenterContainer/Panel/VBoxContainer/ScrollContainer"]
layout_mode = 2
size_flags_vertical = 3

[node name="BackButton" type="Button" parent="CenterContainer/Panel/VBoxContainer"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
text = "Back"


--- FILE: D:\YandexDisk\Projects\Runner\Godot\Coin.gd ---

extends Area2D
# Coin.gd - ИСПРАВЛЕННАЯ ВЕРСИЯ

@export var value: int = 1
@export var radius: float = 16.0

@onready var collision: CollisionShape2D = $CollisionShape2D

func _ready() -> void:
	print("✅ Coin spawned at: ", global_position)
	
	# ВАЖНО: Включаем мониторинг
	monitoring = true
	monitorable = true
	
	# КРИТИЧЕСКИ ВАЖНО: СЛОИ КОЛЛИЗИИ
	# Монета на слое 2, реагирует на маску 1 (игрок)
	set_collision_layer_value(2, true)
	set_collision_mask_value(1, true)
	
	# ВЫКЛЮЧАЕМ все остальные слои
	for i in range(1, 33):
		if i != 2:
			set_collision_layer_value(i, false)
		if i != 1:
			set_collision_mask_value(i, false)

	# СОЗДАЕМ КОЛЛАЙДЕР (круг)
	if collision != null:
		var shape = CircleShape2D.new()
		shape.radius = radius
		collision.shape = shape

	# ПОДКЛЮЧАЕМ СИГНАЛ
	if not body_entered.is_connected(_on_body_entered):
		body_entered.connect(_on_body_entered)
		
	print("✅ Coin setup complete - Layer: 2, Mask: 1")
	queue_redraw()

func _on_body_entered(body: Node) -> void:
	print("🎯 Coin: body entered - ", body.name)
	
	if body is CharacterBody2D and body.name == "Player":
		print("💰 Coin collected! Adding ", value, " points")
		
		# Добавляем очки
		GameState.add_coin(value)
		print("📊 New score: ", GameState.score)
		
		# Исчезаем
		queue_free()

func _draw() -> void:
	# РИСУЕМ КРАСИВУЮ МОНЕТУ
	var center = Vector2.ZERO
	
	# Жёлтая середина
	draw_circle(center, radius, Color(1.0, 0.84, 0.0, 1.0))
	
	# Тёмно-жёлтый ободок
	draw_arc(center, radius, 0, TAU, 32, Color(0.8, 0.6, 0.0, 1.0), 3.0)
	
	# Внутренний круг
	draw_circle(center, radius * 0.6, Color(1.0, 0.9, 0.3, 1.0))
	
	# Блик
	draw_circle(Vector2(-radius * 0.3, -radius * 0.3), radius * 0.2, Color(1.0, 1.0, 1.0, 0.8))


--- FILE: D:\YandexDisk\Projects\Runner\Godot\Coin.tscn ---

[gd_scene load_steps=2 format=3 uid="uid://caso0eomqoq3b"]

[ext_resource type="Script" path="res://Coin.gd" id="1_7hm3t"]

[node name="Coin" type="Area2D"]
script = ExtResource("1_7hm3t")

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]


--- FILE: D:\YandexDisk\Projects\Runner\Godot\GameState.gd ---

extends Node
# ============================================================================
# GameState.gd — Autoload Singleton
# ----------------------------------------------------------------------------
# Хранит:
# - рекорды/таблицу чемпионов
# - выбранного героя
# - настройки кастом-аватара (jump0/jump1)
# - НИКНЕЙМ (persisted) — теперь игра не стартует без него
#
# Закладки под будущий мультиплеер:
# - player_uid (пока локально)
# - auth_provider / auth_token (пока пустые)
# ============================================================================

const SAVE_PATH: String = "user://blackout_run_scores.save"
const MAX_CHAMPIONS: int = 20

const DEFAULT_HERO_ID: String = "default"

# --- PERSISTED PROFILE ---
var nickname: String = ""              # <- ОБЯЗАТЕЛЕН для старта
var player_uid: String = ""            # <- заглушка (мультиплеер)
var auth_provider: String = ""         # <- заглушка (Google/Apple/etc)
var auth_token: String = ""            # <- заглушка

# --- HERO ---
var selected_hero_id: String = DEFAULT_HERO_ID

# --- CUSTOM AVATAR ---
var use_custom_avatar: bool = false
var custom_avatar_up_path: String = "user://avatars/custom_jump_up.png"
var custom_avatar_down_path: String = "user://avatars/custom_jump_down.png"

# --- RUN STATE ---
var score: int = 0
var player_name: String = ""           # имя текущего забега (берём из nickname)

# --- RECORDS ---
var best_score: int = 0
var champions: Array = [] # { "name": String, "score": int, "time": int }

func _ready() -> void:
	load_scores()

# ---------------- PROFILE ----------------

func set_nickname(v: String) -> void:
	nickname = v.strip_edges()
	save_scores()

func get_nickname() -> String:
	return nickname

func has_valid_nickname() -> bool:
	return nickname.strip_edges() != ""

# ---------------- RUN ----------------

func start_new_run() -> void:
	# Имя забега всегда берём из persisted nickname
	score = 0
	player_name = nickname.strip_edges()

func add_coin(value: int = 1) -> void:
	score += value
	if score > best_score:
		best_score = score

# ---------------- HERO ----------------

func set_selected_hero_id(id: String) -> void:
	var clean_id := id.strip_edges()
	if clean_id == "":
		clean_id = DEFAULT_HERO_ID
	selected_hero_id = clean_id
	save_scores()

func get_selected_hero_id() -> String:
	return selected_hero_id

# ---------------- CUSTOM AVATAR ----------------

func set_use_custom_avatar(v: bool) -> void:
	use_custom_avatar = v
	save_scores()

func get_use_custom_avatar() -> bool:
	return use_custom_avatar

func set_custom_avatar_paths(up_path: String, down_path: String) -> void:
	if up_path.strip_edges() != "":
		custom_avatar_up_path = up_path.strip_edges()
	if down_path.strip_edges() != "":
		custom_avatar_down_path = down_path.strip_edges()
	save_scores()

func get_custom_avatar_up_path() -> String:
	return custom_avatar_up_path

func get_custom_avatar_down_path() -> String:
	return custom_avatar_down_path

# ---------------- CHAMPIONS ----------------

func register_run_finished() -> void:
	var player_n := player_name.strip_edges()
	if player_n == "":
		player_n = "NoName"

	var entry := {
		"name": player_n,
		"score": score,
		"time": _get_now()
	}

	champions.append(entry)
	champions.sort_custom(Callable(self, "_sort_scores_desc"))

	if champions.size() > MAX_CHAMPIONS:
		champions.resize(MAX_CHAMPIONS)

	save_scores()

func get_champions() -> Array:
	return champions.duplicate()

func reset_scores() -> void:
	score = 0
	best_score = 0
	champions.clear()
	save_scores()

# ---------------- SAVE/LOAD ----------------

func save_scores() -> void:
	var file := FileAccess.open(SAVE_PATH, FileAccess.WRITE)
	if file == null:
		push_error("GameState: не удалось открыть файл для записи: " + SAVE_PATH)
		return

	var data := {
		# profile
		"nickname": nickname,
		"player_uid": player_uid,
		"auth_provider": auth_provider,
		"auth_token": auth_token,

		# records
		"best_score": best_score,
		"champions": champions,

		# hero
		"selected_hero_id": selected_hero_id,

		# custom avatar
		"use_custom_avatar": use_custom_avatar,
		"custom_avatar_up_path": custom_avatar_up_path,
		"custom_avatar_down_path": custom_avatar_down_path
	}

	file.store_var(data)

func load_scores() -> void:
	if not FileAccess.file_exists(SAVE_PATH):
		_reset_to_defaults()
		return

	var file := FileAccess.open(SAVE_PATH, FileAccess.READ)
	if file == null:
		push_error("GameState: не удалось открыть файл для чтения: " + SAVE_PATH)
		_reset_to_defaults()
		return

	var data = file.get_var()
	if typeof(data) != TYPE_DICTIONARY:
		_reset_to_defaults()
		return

	# profile
	nickname = str(data.get("nickname", "")).strip_edges()
	player_uid = str(data.get("player_uid", "")).strip_edges()
	auth_provider = str(data.get("auth_provider", "")).strip_edges()
	auth_token = str(data.get("auth_token", "")).strip_edges()

	# records
	best_score = int(data.get("best_score", 0))

	var loaded_champs = data.get("champions", [])
	champions.clear()
	if typeof(loaded_champs) == TYPE_ARRAY:
		for e in loaded_champs:
			if typeof(e) == TYPE_DICTIONARY:
				champions.append(e)
	champions.sort_custom(Callable(self, "_sort_scores_desc"))
	if champions.size() > MAX_CHAMPIONS:
		champions.resize(MAX_CHAMPIONS)

	# hero
	selected_hero_id = str(data.get("selected_hero_id", DEFAULT_HERO_ID)).strip_edges()
	if selected_hero_id == "":
		selected_hero_id = DEFAULT_HERO_ID

	# custom avatar
	use_custom_avatar = bool(data.get("use_custom_avatar", false))
	custom_avatar_up_path = str(data.get("custom_avatar_up_path", "user://avatars/custom_jump_up.png")).strip_edges()
	custom_avatar_down_path = str(data.get("custom_avatar_down_path", "user://avatars/custom_jump_down.png")).strip_edges()

	if custom_avatar_up_path == "":
		custom_avatar_up_path = "user://avatars/custom_jump_up.png"
	if custom_avatar_down_path == "":
		custom_avatar_down_path = "user://avatars/custom_jump_down.png"

func _reset_to_defaults() -> void:
	nickname = ""
	player_uid = ""
	auth_provider = ""
	auth_token = ""

	score = 0
	player_name = ""
	best_score = 0
	champions.clear()

	selected_hero_id = DEFAULT_HERO_ID

	use_custom_avatar = false
	custom_avatar_up_path = "user://avatars/custom_jump_up.png"
	custom_avatar_down_path = "user://avatars/custom_jump_down.png"

func _sort_scores_desc(a: Dictionary, b: Dictionary) -> bool:
	var sa: int = int(a.get("score", 0))
	var sb: int = int(b.get("score", 0))
	if sa == sb:
		var ta: int = int(a.get("time", 0))
		var tb: int = int(b.get("time", 0))
		return ta > tb
	return sa > sb

func _get_now() -> int:
	return Time.get_unix_time_from_system()


--- FILE: D:\YandexDisk\Projects\Runner\Godot\HUD.gd ---

extends Control
# HUD.gd — отображает текущий счёт и имя игрока

@export_file("*.tscn")
var main_menu_scene: String = "res://MainMenu.tscn"

@onready var score_label: Label = $VBoxContainer/ScoreLabel
@onready var name_label: Label = $VBoxContainer/NameLabel
@onready var back_button: Button = $BackButton

func _ready() -> void:
	if back_button != null and not back_button.pressed.is_connected(_on_back_button_pressed):
		back_button.pressed.connect(_on_back_button_pressed)
	_refresh_labels()

func _process(_delta: float) -> void:
	_refresh_labels()

func _refresh_labels() -> void:
	var pn := GameState.player_name
	if pn == "" or pn == "NoName":
		pn = "NoName"
	score_label.text = "Score: " + str(GameState.score)
	name_label.text = "Player: " + pn

func _on_back_button_pressed() -> void:
	if not Engine.is_editor_hint():
		GameState.register_run_finished()
		if main_menu_scene == "":
			push_error("HUD: не задан путь к сцене главного меню (main_menu_scene).")
			return
		var err := get_tree().change_scene_to_file(main_menu_scene)
		if err != OK:
			push_error("HUD: не удалось загрузить сцену главного меню: " + main_menu_scene)


--- FILE: D:\YandexDisk\Projects\Runner\Godot\level.tscn ---

[gd_scene load_steps=12 format=3 uid="uid://dqjhrv658k7px"]

[ext_resource type="Script" uid="uid://b1f0nnjwe1y4n" path="res://scripts/Level.gd" id="1_dp35j"]
[ext_resource type="Script" uid="uid://d2qhqiwwdgihd" path="res://scripts/Player.gd" id="2_hc4jq"]
[ext_resource type="SpriteFrames" uid="uid://c0nyy5461gg26" path="res://heroes/hero_default_jump_frames.tres" id="3_default_frames"]
[ext_resource type="Script" uid="uid://yfnnihpjke51" path="res://HUD.gd" id="4_kqdme"]
[ext_resource type="SpriteFrames" uid="uid://blt1544junb0x" path="res://heroes/hero_monster_jump_frames.tres" id="4_mtnfr"]
[ext_resource type="SpriteFrames" uid="uid://keh6xhe2lv" path="res://heroes/hero_red_jump_frames.tres" id="5_tdk6w"]
[ext_resource type="SpriteFrames" uid="uid://b5liyg33sbvg0" path="res://heroes/hero_blue_jump_frames.tres" id="6_km5ld"]
[ext_resource type="SpriteFrames" uid="uid://cpcmabbbk00du" path="res://heroes/hero_orange_jump_frames.tres" id="7_i2t4f"]
[ext_resource type="PackedScene" uid="uid://dpol13adfo7g3" path="res://wall/wall.tscn" id="8_wall"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_oqtl3"]
size = Vector2(16, 32)

[sub_resource type="SpriteFrames" id="SpriteFrames_pdllj"]
animations = [{
"frames": [],
"loop": true,
"name": &"JUMP",
"speed": 5.0
}]

[node name="Level" type="Node2D"]
script = ExtResource("1_dp35j")

[node name="Platforms" type="Node2D" parent="."]

[node name="Wall" parent="." instance=ExtResource("8_wall")]

[node name="Player" type="CharacterBody2D" parent="."]
position = Vector2(200, 250)
up_direction = Vector2(0, 1)
script = ExtResource("2_hc4jq")
main_menu_scene = "uid://dhfx3og1cf0cj"
frames_default = ExtResource("3_default_frames")
frames_monster = ExtResource("4_mtnfr")
frames_red = ExtResource("5_tdk6w")
frames_blue = ExtResource("6_km5ld")
frames_orange = ExtResource("7_i2t4f")

[node name="Camera2D" type="Camera2D" parent="Player"]
zoom = Vector2(1.2, 1.2)
drag_vertical_enabled = true
drag_top_margin = 0.25
drag_bottom_margin = 0.45
editor_draw_drag_margin = true

[node name="CollisionShape2D" type="CollisionShape2D" parent="Player"]
shape = SubResource("RectangleShape2D_oqtl3")

[node name="AnimatedSprite2D" type="AnimatedSprite2D" parent="Player"]
scale = Vector2(0.6, 0.6)
sprite_frames = SubResource("SpriteFrames_pdllj")
animation = &"JUMP"

[node name="CustomAvatarSprite" type="Sprite2D" parent="Player"]
visible = false
scale = Vector2(0.6, 0.6)

[node name="HUDLayer" type="CanvasLayer" parent="."]

[node name="HUD" type="Control" parent="HUDLayer"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("4_kqdme")

[node name="VBoxContainer" type="VBoxContainer" parent="HUDLayer/HUD"]
layout_mode = 1
offset_left = 16.0
offset_top = 16.0
offset_right = 56.0
offset_bottom = 66.0

[node name="NameLabel" type="Label" parent="HUDLayer/HUD/VBoxContainer"]
layout_mode = 2

[node name="ScoreLabel" type="Label" parent="HUDLayer/HUD/VBoxContainer"]
layout_mode = 2

[node name="BackButton" type="Button" parent="HUDLayer/HUD"]
layout_mode = 1
anchors_preset = 1
anchor_left = 1.0
anchor_right = 1.0
offset_left = -120.0
offset_top = 16.0
offset_right = -67.0
offset_bottom = 47.0
grow_horizontal = 0
text = "Menu"


--- FILE: D:\YandexDisk\Projects\Runner\Godot\MainMenu.gd ---

extends Control
# ============================================================================
# MainMenu.gd — ГЛАВНЫЙ ЭКРАН (без настроек аватара)
# ----------------------------------------------------------------------------
# Требования:
# - Play НЕ работает без nickname
# - Champions -> отдельная сцена
# - Profile -> отдельная сцена (там nickname + avatar + jump(0/1))
# - На главном экране показываем текущий аватар (по выбору игрока)
# ============================================================================

@export_file("*.tscn")
var game_scene: String = "res://level.tscn"

@export_file("*.tscn")
var champions_scene: String = "res://Champions.tscn"

@export_file("*.tscn")
var profile_scene: String = "res://Profile.tscn"

@onready var play_button: Button = $CenterContainer/Panel/VBoxContainer/PlayButton
@onready var champions_button: Button = $CenterContainer/Panel/VBoxContainer/ChampionsButton
@onready var profile_button: Button = $CenterContainer/Panel/VBoxContainer/ProfileButton
@onready var google_button: Button = $CenterContainer/Panel/VBoxContainer/GoogleButton

@onready var nickname_label: Label = $CenterContainer/Panel/VBoxContainer/NicknameLabel
@onready var avatar_preview: TextureRect = $CenterContainer/Panel/VBoxContainer/AvatarPreview

@onready var warn_dialog: AcceptDialog = $WarnDialog

const HERO_PREVIEWS := {
	"default": "res://heroes/hero_default.png",
	"monster": "res://heroes/hero_monster.png",
	"red": "res://heroes/hero_red.png",
	"blue": "res://heroes/hero_blue.png",
	"orange": "res://heroes/hero_orange.png"
}

func _ready() -> void:
	if google_button:
		google_button.disabled = true

	if play_button and not play_button.pressed.is_connected(_on_play_pressed):
		play_button.pressed.connect(_on_play_pressed)

	if champions_button and not champions_button.pressed.is_connected(_on_champions_pressed):
		champions_button.pressed.connect(_on_champions_pressed)

	if profile_button and not profile_button.pressed.is_connected(_on_profile_pressed):
		profile_button.pressed.connect(_on_profile_pressed)

	_refresh_ui()

func _process(_delta: float) -> void:
	# лёгкий refresh (тут нет тяжёлых операций)
	_refresh_ui()

func _refresh_ui() -> void:
	var nick := GameState.get_nickname().strip_edges()
	if nickname_label:
		nickname_label.text = "Nickname: " + (nick if nick != "" else "— не задан —")

	# Показываем превью аватара:
	# - если кастом включён и есть файл jump0 -> показываем его
	# - иначе показываем preview выбранного героя
	if avatar_preview == null:
		return

	if GameState.get_use_custom_avatar():
		var up_path := GameState.get_custom_avatar_up_path()
		if FileAccess.file_exists(up_path):
			var img := Image.new()
			var err := img.load(up_path)
			if err == OK:
				var tex := ImageTexture.create_from_image(img)
				avatar_preview.texture = tex
				return

	var hero_id := str(GameState.get_selected_hero_id()).strip_edges()
	if hero_id == "":
		hero_id = "default"
	var p := str(HERO_PREVIEWS.get(hero_id, HERO_PREVIEWS["default"]))
	if p != "" and ResourceLoader.exists(p):
		var res := ResourceLoader.load(p, "", ResourceLoader.CACHE_MODE_REPLACE)
		if res is Texture2D:
			avatar_preview.texture = res

func _on_profile_pressed() -> void:
	var err := get_tree().change_scene_to_file(profile_scene)
	if err != OK:
		push_error("MainMenu.gd: не удалось открыть Profile: " + profile_scene)

func _on_champions_pressed() -> void:
	var err := get_tree().change_scene_to_file(champions_scene)
	if err != OK:
		push_error("MainMenu.gd: не удалось открыть Champions: " + champions_scene)

func _on_play_pressed() -> void:
	# Запрет старта без nickname
	if not GameState.has_valid_nickname():
		_show_warn("Сначала нужно указать никнейм (Profile).")
		return

	# старт забега
	GameState.start_new_run()

	var err := get_tree().change_scene_to_file(game_scene)
	if err != OK:
		push_error("MainMenu.gd: не удалось загрузить сцену игры: " + game_scene)

func _show_warn(text: String) -> void:
	if warn_dialog:
		warn_dialog.dialog_text = text
		warn_dialog.popup_centered()


--- FILE: D:\YandexDisk\Projects\Runner\Godot\MainMenu.tscn ---

[gd_scene load_steps=2 format=3 uid="uid://dhfx3og1cf0cj"]

[ext_resource type="Script" uid="uid://bccj45bqt7cxy" path="res://MainMenu.gd" id="1_nsm8v"]

[node name="MainMenu" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_nsm8v")

[node name="CenterContainer" type="CenterContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="Panel" type="Panel" parent="CenterContainer"]
custom_minimum_size = Vector2(900, 620)
layout_mode = 2

[node name="VBoxContainer" type="VBoxContainer" parent="CenterContainer/Panel"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 24.0
offset_top = 24.0
offset_right = -24.0
offset_bottom = -24.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 14

[node name="TitleLabel" type="Label" parent="CenterContainer/Panel/VBoxContainer"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2
theme_override_font_sizes/font_size = 32
text = "BLACKOUT RUN"

[node name="NicknameLabel" type="Label" parent="CenterContainer/Panel/VBoxContainer"]
custom_minimum_size = Vector2(0, 40)
layout_mode = 2
text = "Nickname: —"

[node name="AvatarPreview" type="TextureRect" parent="CenterContainer/Panel/VBoxContainer"]
custom_minimum_size = Vector2(140, 140)
layout_mode = 2
expand_mode = 1
stretch_mode = 5

[node name="PlayButton" type="Button" parent="CenterContainer/Panel/VBoxContainer"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2
theme_override_font_sizes/font_size = 32
text = "Play"

[node name="ChampionsButton" type="Button" parent="CenterContainer/Panel/VBoxContainer"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2
theme_override_font_sizes/font_size = 32
text = "Champions"

[node name="ProfileButton" type="Button" parent="CenterContainer/Panel/VBoxContainer"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2
theme_override_font_sizes/font_size = 32
text = "Profile"

[node name="GoogleButton" type="Button" parent="CenterContainer/Panel/VBoxContainer"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2
theme_override_font_sizes/font_size = 32
text = "Вход через Google"

[node name="WarnDialog" type="AcceptDialog" parent="."]
oversampling_override = 1.0
title = "Внимание"
dialog_text = "..."


--- FILE: D:\YandexDisk\Projects\Runner\Godot\Platform.tscn ---

[gd_scene load_steps=3 format=3 uid="uid://be75ddpx283h6"]

[ext_resource type="Script" uid="uid://d3vnfw24h7bdb" path="res://scripts/Platform.gd" id="1_hyugo"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_s2m6q"]
size = Vector2(32, 32)

[node name="Platform" type="StaticBody2D"]
constant_linear_velocity = Vector2(64, 64)
script = ExtResource("1_hyugo")
coin_spawn_chance = 0.3

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_s2m6q")


--- FILE: D:\YandexDisk\Projects\Runner\Godot\Profile.gd ---

extends Control
# ============================================================================
# Profile.gd — отдельная сцена профиля игрока (nickname + выбор героя + кастом-аватар jump(0/1))
# ----------------------------------------------------------------------------
# ТРЕБОВАНИЕ (твое):
# ✅ Любая картинка, которую загружает ИГРОК (png/jpg/jpeg), должна в игре быть 64x64
#    БЕЗ ОБРЕЗКИ — только уменьшение/вписывание с сохранением пропорций.
#
# КАК ЭТО РЕШЕНО (без ломания твоей логики и без влияния на встроенных героев):
# 1) При выборе файла (jump0/jump1) мы загружаем Image из исходника (png/jpg/jpeg).
# 2) Вписываем в квадрат 64x64 (прозрачный фон), без обрезки.
# 3) Сохраняем в user://avatars/custom_jump_up.png и custom_jump_down.png.
# 4) GameState пути оставляем как у тебя (ничего не ломаем).
#
# ВАЖНО:
# - Встроенные спрайты героев (которые ты задаёшь в инспекторе) НЕ трогаем.
# - Меняем ТОЛЬКО то, что загрузил игрок.
# ============================================================================

@export_file("*.tscn")
var main_menu_scene: String = "res://MainMenu.tscn"

@onready var nickname_edit: LineEdit = $CenterContainer/Panel/VBoxContainer/NicknameEdit
@onready var save_button: Button = $CenterContainer/Panel/VBoxContainer/ButtonsRow/SaveButton
@onready var back_button: Button = $CenterContainer/Panel/VBoxContainer/ButtonsRow/BackButton

@onready var hero_left_button: Button = $CenterContainer/Panel/VBoxContainer/HeroSelector/HeroLeftButton
@onready var hero_right_button: Button = $CenterContainer/Panel/VBoxContainer/HeroSelector/HeroRightButton
@onready var hero_preview: TextureRect = $CenterContainer/Panel/VBoxContainer/HeroSelector/HeroPreview
@onready var hero_name_label: Label = $CenterContainer/Panel/VBoxContainer/HeroSelector/HeroNameLabel

@onready var custom_avatar_check: CheckBox = $CenterContainer/Panel/VBoxContainer/CustomAvatarRow/CustomAvatarCheck
@onready var upload_jump_up_button: Button = $CenterContainer/Panel/VBoxContainer/CustomAvatarRow/UploadJumpUpButton
@onready var upload_jump_down_button: Button = $CenterContainer/Panel/VBoxContainer/CustomAvatarRow/UploadJumpDownButton

@onready var file_dialog_jump_up: FileDialog = $FileDialogJumpUp
@onready var file_dialog_jump_down: FileDialog = $FileDialogJumpDown

@onready var warn_dialog: AcceptDialog = $WarnDialog

const HEROES: Array = [
	{"id": "default", "name": "Runner AYO", "preview_png": "res://heroes/hero_default.png"},
	{"id": "monster", "name": "Monster",    "preview_png": "res://heroes/hero_monster.png"},
	{"id": "red",     "name": "Red",        "preview_png": "res://heroes/hero_red.png"},
	{"id": "blue", "name": "Blue",   	 	"preview_png": "res://heroes/hero_blue.png"},
	{"id": "orange", "name": "Orange",  	"preview_png": "res://heroes/hero_orange.png"}
]

const AVATAR_DIR: String = "user://avatars"
const AVATAR_UP_PNG: String = "user://avatars/custom_jump_up.png"
const AVATAR_DOWN_PNG: String = "user://avatars/custom_jump_down.png"

# Целевой размер пользовательских аватарок (то, что загрузил игрок)
const AVATAR_TARGET_SIZE_PX: int = 64

var _hero_index: int = 0

func _ready() -> void:
	# --- nickname ---
	if nickname_edit:
		nickname_edit.text = GameState.get_nickname()
		nickname_edit.grab_focus()

	# --- buttons ---
	if save_button and not save_button.pressed.is_connected(_on_save_pressed):
		save_button.pressed.connect(_on_save_pressed)

	if back_button and not back_button.pressed.is_connected(_on_back_pressed):
		back_button.pressed.connect(_on_back_pressed)

	# --- heroes ---
	if hero_left_button and not hero_left_button.pressed.is_connected(_on_hero_left_pressed):
		hero_left_button.pressed.connect(_on_hero_left_pressed)

	if hero_right_button and not hero_right_button.pressed.is_connected(_on_hero_right_pressed):
		hero_right_button.pressed.connect(_on_hero_right_pressed)

	var saved_id: String = str(GameState.get_selected_hero_id())
	_hero_index = _find_hero_index_by_id(saved_id)
	_apply_hero_to_ui()

	# --- custom avatar ---
	if custom_avatar_check:
		custom_avatar_check.button_pressed = bool(GameState.get_use_custom_avatar())
		if not custom_avatar_check.toggled.is_connected(_on_custom_avatar_toggled):
			custom_avatar_check.toggled.connect(_on_custom_avatar_toggled)

	if upload_jump_up_button and not upload_jump_up_button.pressed.is_connected(_on_upload_jump_up_pressed):
		upload_jump_up_button.pressed.connect(_on_upload_jump_up_pressed)

	if upload_jump_down_button and not upload_jump_down_button.pressed.is_connected(_on_upload_jump_down_pressed):
		upload_jump_down_button.pressed.connect(_on_upload_jump_down_pressed)

	# dialogs signals
	if file_dialog_jump_up and not file_dialog_jump_up.file_selected.is_connected(_on_jump_up_file_selected):
		file_dialog_jump_up.file_selected.connect(_on_jump_up_file_selected)

	if file_dialog_jump_down and not file_dialog_jump_down.file_selected.is_connected(_on_jump_down_file_selected):
		file_dialog_jump_down.file_selected.connect(_on_jump_down_file_selected)

	# Desktop: native dialog (Windows/macOS/Linux)
	# Примечание: на Android/iOS может быть не fully-native без плагина — это нормально.
	if file_dialog_jump_up:
		file_dialog_jump_up.use_native_dialog = true
	if file_dialog_jump_down:
		file_dialog_jump_down.use_native_dialog = true

	_update_custom_avatar_buttons_state()

func _unhandled_input(event: InputEvent) -> void:
	if event is InputEventKey and event.pressed and event.keycode == KEY_ESCAPE:
		_on_back_pressed()

# ---------------- HERO SELECTOR ----------------

func _find_hero_index_by_id(id: String) -> int:
	var clean_id: String = id.strip_edges()
	if clean_id == "":
		return 0
	for i in range(HEROES.size()):
		var h = HEROES[i]
		if typeof(h) == TYPE_DICTIONARY and str(h.get("id", "")) == clean_id:
			return int(i)
	return 0

func _apply_hero_to_ui() -> void:
	if HEROES.is_empty():
		return

	if _hero_index < 0:
		_hero_index = HEROES.size() - 1
	if _hero_index >= HEROES.size():
		_hero_index = 0

	var hero = HEROES[_hero_index]
	if typeof(hero) != TYPE_DICTIONARY:
		return

	var hero_display_name: String = str(hero.get("name", "Hero"))
	if hero_name_label:
		hero_name_label.text = hero_display_name

	var preview_path: String = str(hero.get("preview_png", ""))
	if hero_preview:
		if preview_path != "" and ResourceLoader.exists(preview_path):
			var res := ResourceLoader.load(preview_path, "", ResourceLoader.CACHE_MODE_REPLACE)
			if res is Texture2D:
				hero_preview.texture = res

func _save_current_hero_to_gamestate() -> void:
	if HEROES.is_empty():
		return
	var hero = HEROES[_hero_index]
	if typeof(hero) != TYPE_DICTIONARY:
		return

	var hero_id: String = str(hero.get("id", "default")).strip_edges()
	if hero_id == "":
		hero_id = "default"

	GameState.set_selected_hero_id(hero_id)

func _on_hero_left_pressed() -> void:
	_hero_index -= 1
	if _hero_index < 0:
		_hero_index = HEROES.size() - 1
	_apply_hero_to_ui()
	_save_current_hero_to_gamestate()

func _on_hero_right_pressed() -> void:
	_hero_index += 1
	if _hero_index >= HEROES.size():
		_hero_index = 0
	_apply_hero_to_ui()
	_save_current_hero_to_gamestate()

# ---------------- CUSTOM AVATAR ----------------

func _on_custom_avatar_toggled(pressed: bool) -> void:
	GameState.set_use_custom_avatar(pressed)
	_update_custom_avatar_buttons_state()

func _update_custom_avatar_buttons_state() -> void:
	var enabled := custom_avatar_check != null and custom_avatar_check.button_pressed

	if upload_jump_up_button:
		upload_jump_up_button.disabled = not enabled
	if upload_jump_down_button:
		upload_jump_down_button.disabled = not enabled

func _on_upload_jump_up_pressed() -> void:
	if file_dialog_jump_up:
		file_dialog_jump_up.popup_centered_ratio(0.85)

func _on_upload_jump_down_pressed() -> void:
	if file_dialog_jump_down:
		file_dialog_jump_down.popup_centered_ratio(0.85)

func _ensure_user_avatar_dir() -> void:
	# Создаём user://avatars если его нет
	if not DirAccess.dir_exists_absolute(AVATAR_DIR):
		var mk_err: int = DirAccess.make_dir_recursive_absolute(AVATAR_DIR)
		if mk_err != OK:
			push_warning("Profile.gd: не удалось создать папку: " + AVATAR_DIR + " err=" + str(mk_err))

func _import_image_as_png_to_user(source_path: String, target_user_png_path: String) -> bool:
	# Ключевая логика:
	# 1) грузим картинку (png/jpg/jpeg)
	# 2) вписываем в квадрат 64x64 без обрезки
	# 3) сохраняем как PNG в user://avatars/...
	_ensure_user_avatar_dir()

	var img: Image = Image.new()
	var err_load: int = img.load(source_path)
	if err_load != OK:
		push_warning("Profile.gd: не удалось загрузить изображение: " + source_path + " err=" + str(err_load))
		return false

	# Приводим к RGBA8 (для корректной работы с прозрачностью/ресайзом)
	if img.get_format() != Image.FORMAT_RGBA8:
		img.convert(Image.FORMAT_RGBA8)

	# Вписываем в 64x64 (прозрачные поля по бокам/сверху если нужно)
	var fitted: Image = _fit_image_into_square(img, AVATAR_TARGET_SIZE_PX)

	# Сохраняем уже НОРМАЛЬНЫЙ PNG (и всегда 64x64)
	var err_save: int = fitted.save_png(target_user_png_path)
	if err_save != OK:
		push_warning("Profile.gd: не удалось сохранить PNG в: " + target_user_png_path + " err=" + str(err_save))
		return false

	return true

func _on_jump_up_file_selected(path: String) -> void:
	var ok := _import_image_as_png_to_user(path, AVATAR_UP_PNG)
	if ok:
		GameState.set_custom_avatar_paths(AVATAR_UP_PNG, GameState.get_custom_avatar_down_path())
		print("✅ Saved custom jump(0) as 64x64: ", AVATAR_UP_PNG)
	else:
		_show_warn("Не удалось загрузить jump(0). Попробуй PNG/JPG/JPEG без повреждений.")

func _on_jump_down_file_selected(path: String) -> void:
	var ok := _import_image_as_png_to_user(path, AVATAR_DOWN_PNG)
	if ok:
		GameState.set_custom_avatar_paths(GameState.get_custom_avatar_up_path(), AVATAR_DOWN_PNG)
		print("✅ Saved custom jump(1) as 64x64: ", AVATAR_DOWN_PNG)
	else:
		_show_warn("Не удалось загрузить jump(1). Попробуй PNG/JPG/JPEG без повреждений.")

# ---------------- SAVE / BACK ----------------

func _on_save_pressed() -> void:
	var nick := ""
	if nickname_edit:
		nick = nickname_edit.text.strip_edges()

	if nick == "":
		_show_warn("Нужно заполнить никнейм!")
		return

	GameState.set_nickname(nick)
	_save_current_hero_to_gamestate()

	# если пользователь включил кастом-аватар — проверим что файлы существуют
	if GameState.get_use_custom_avatar():
		var up_ok := FileAccess.file_exists(GameState.get_custom_avatar_up_path())
		var dn_ok := FileAccess.file_exists(GameState.get_custom_avatar_down_path())
		if not up_ok or not dn_ok:
			_show_warn("Кастом-аватар включён, но jump(0) или jump(1) не загружены.")
			return

	_on_back_pressed()

func _on_back_pressed() -> void:
	var err := get_tree().change_scene_to_file(main_menu_scene)
	if err != OK:
		push_error("Profile.gd: не удалось вернуться в меню: " + main_menu_scene)

func _show_warn(text: String) -> void:
	if warn_dialog:
		warn_dialog.dialog_text = text
		warn_dialog.popup_centered()
	else:
		push_warning("WARN: " + text)

# ---------------- IMAGE HELPERS ----------------

func _fit_image_into_square(src: Image, target_size: int) -> Image:
	# Вписываем изображение в квадрат target_size x target_size БЕЗ ОБРЕЗКИ.
	# - сохраняем пропорции
	# - добавляем прозрачные поля где нужно
	# - итог всегда ровно target_size x target_size
	var src_w: int = src.get_width()
	var src_h: int = src.get_height()

	if src_w <= 0 or src_h <= 0:
		return src

	var dst: Image = Image.create(target_size, target_size, false, Image.FORMAT_RGBA8)
	dst.fill(Color(0, 0, 0, 0))

	# Работаем с копией, чтобы не портить исходный Image
	var resized: Image = src.duplicate()
	if resized.get_format() != Image.FORMAT_RGBA8:
		resized.convert(Image.FORMAT_RGBA8)

	# Масштаб "вписать"
	var scale: float = minf(float(target_size) / float(src_w), float(target_size) / float(src_h))

	# Даже если картинка маленькая — всё равно приведём к предсказуемому размеру (64x64)
	var new_w: int = maxi(1, int(round(float(src_w) * scale)))
	var new_h: int = maxi(1, int(round(float(src_h) * scale)))

	resized.resize(new_w, new_h, Image.INTERPOLATE_LANCZOS)

	# Центрируем
	var x: int = int((target_size - new_w) / 2)
	var y: int = int((target_size - new_h) / 2)

	dst.blit_rect(resized, Rect2i(0, 0, new_w, new_h), Vector2i(x, y))
	return dst


--- FILE: D:\YandexDisk\Projects\Runner\Godot\Profile.tscn ---

[gd_scene load_steps=2 format=3 uid="uid://dg133jef00bhu"]

[ext_resource type="Script" uid="uid://ce7583hntybfd" path="res://Profile.gd" id="1_profile"]

[node name="Profile" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_profile")

[node name="CenterContainer" type="CenterContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="Panel" type="Panel" parent="CenterContainer"]
custom_minimum_size = Vector2(900, 620)
layout_mode = 2

[node name="VBoxContainer" type="VBoxContainer" parent="CenterContainer/Panel"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 24.0
offset_top = 24.0
offset_right = -24.0
offset_bottom = -24.0
grow_horizontal = 2
grow_vertical = 2

[node name="TitleLabel" type="Label" parent="CenterContainer/Panel/VBoxContainer"]
layout_mode = 2
theme_override_font_sizes/font_size = 32
text = "Profile"

[node name="NicknameEdit" type="LineEdit" parent="CenterContainer/Panel/VBoxContainer"]
custom_minimum_size = Vector2(0, 72)
layout_mode = 2
theme_override_font_sizes/font_size = 28
placeholder_text = "Введите никнейм"

[node name="HeroSelector" type="HBoxContainer" parent="CenterContainer/Panel/VBoxContainer"]
layout_mode = 2
theme_override_constants/separation = 16
alignment = 1

[node name="HeroLeftButton" type="Button" parent="CenterContainer/Panel/VBoxContainer/HeroSelector"]
layout_mode = 2
text = "<"

[node name="HeroPreview" type="TextureRect" parent="CenterContainer/Panel/VBoxContainer/HeroSelector"]
custom_minimum_size = Vector2(110, 110)
layout_mode = 2
expand_mode = 1
stretch_mode = 5

[node name="HeroRightButton" type="Button" parent="CenterContainer/Panel/VBoxContainer/HeroSelector"]
layout_mode = 2
text = ">"

[node name="HeroNameLabel" type="Label" parent="CenterContainer/Panel/VBoxContainer/HeroSelector"]
layout_mode = 2
text = "Runner AYO"

[node name="CustomAvatarRow" type="VBoxContainer" parent="CenterContainer/Panel/VBoxContainer"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="CustomAvatarCheck" type="CheckBox" parent="CenterContainer/Panel/VBoxContainer/CustomAvatarRow"]
layout_mode = 2
text = "Свой аватар (2 фото: jump0/jump1)"

[node name="UploadJumpUpButton" type="Button" parent="CenterContainer/Panel/VBoxContainer/CustomAvatarRow"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
text = "Загрузить jump(0)"

[node name="UploadJumpDownButton" type="Button" parent="CenterContainer/Panel/VBoxContainer/CustomAvatarRow"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
text = "Загрузить jump(1)"

[node name="ButtonsRow" type="HBoxContainer" parent="CenterContainer/Panel/VBoxContainer"]
layout_mode = 2
theme_override_constants/separation = 16
alignment = 1

[node name="SaveButton" type="Button" parent="CenterContainer/Panel/VBoxContainer/ButtonsRow"]
custom_minimum_size = Vector2(240, 64)
layout_mode = 2
text = "Save"

[node name="BackButton" type="Button" parent="CenterContainer/Panel/VBoxContainer/ButtonsRow"]
custom_minimum_size = Vector2(240, 64)
layout_mode = 2
text = "Back"

[node name="FileDialogJumpUp" type="FileDialog" parent="."]
title = "Open a File"
ok_button_text = "Открыть"
dialog_hide_on_ok = true
file_mode = 0
access = 2
filters = PackedStringArray("*.png ; PNG Images", "*.jpg ; JPG Images", "*.jpeg ; JPEG Images")

[node name="FileDialogJumpDown" type="FileDialog" parent="."]
title = "Open a File"
ok_button_text = "Открыть"
dialog_hide_on_ok = true
file_mode = 0
access = 2
filters = PackedStringArray("*.png ; PNG Images", "*.jpg ; JPG Images", "*.jpeg ; JPEG Images")

[node name="WarnDialog" type="AcceptDialog" parent="."]
title = "Внимание"
dialog_text = "..."


--- FILE: D:\YandexDisk\Projects\Runner\Godot\scripts\Level.gd ---

extends Node2D
# Level.gd — твой фундамент + безопасное чтение параметров Player через get()

@onready var player: CharacterBody2D = $Player
@onready var platforms_root: Node2D = $Platforms

var platform_scene: PackedScene = preload("res://Platform.tscn")
var rng: RandomNumberGenerator = RandomNumberGenerator.new()

const TILE_SIZE: float = 64.0
const PLATFORM_HEIGHT: float = 64.0

const MAIN_MIN_SEGMENTS: int = 2
const MAIN_MAX_SEGMENTS: int = 6

const DECOY_MIN_SEGMENTS: int = 1
const DECOY_MAX_SEGMENTS: int = 10

const SAFE_MAIN_GAP_X: float = 220.0

const MIN_EDGE_GAP: float = 32.0
const MAX_EDGE_GAP: float = SAFE_MAIN_GAP_X

const MIN_VERTICAL_GAP: float = 32.0
const MIN_TOTAL_PLATFORMS: int = 10

const PLAYER_SPEED_X: float = 350.0
const SEGMENT_TIME_SECONDS: float = 7.0 * 60.0
const WORLD_WIDTH: float = PLAYER_SPEED_X * SEGMENT_TIME_SECONDS
const LEFT_WALL_X: float = 0.0
const RIGHT_WALL_X: float = WORLD_WIDTH

const DY_STEP: float = 64.0

const DECOY_OFFSET_X_MIN: float = SAFE_MAIN_GAP_X * 1.6
const DECOY_OFFSET_X_MAX: float = SAFE_MAIN_GAP_X * 2.0

@export var WORLD_SCREENS: int = 20
@export var USE_FIXED_WORLD_WIDTH: bool = false
@export var FIXED_WORLD_WIDTH: float = 8000.0
@export var HORIZONTAL_WORLD_MARGIN: float = 256.0

const SAFE_MARGIN_X: float = 32.0

@export var DIFFICULTY_PER_STEP: float = 0.0025
@export var DIFFICULTY_START: float = 0.01
@export var DIFFICULTY_MAX: float = 0.1
var difficulty: float = 0.0

@export var GAP_MIN_PCT_EASY: float = 0.20
@export var GAP_MAX_PCT_EASY: float = 0.55
@export var GAP_MIN_PCT_HARD: float = 0.45
@export var GAP_MAX_PCT_HARD: float = 0.90

@export var MIN_MAIN_EDGE_GAP_ABS: float = 100.0
@export var MAX_MAIN_EDGE_GAP_ABS: float = 260.0

var viewport_width: float = 0.0
var viewport_height: float = 0.0

var min_center_x: float = 0.0
var max_center_x: float = 0.0

var platforms: Array[Node2D] = []

var last_main_pos: Vector2 = Vector2.ZERO
var last_main_segments: int = 4

var going_right: bool = true

var wall_clamp_count: int = 0
const WALL_CLAMP_THRESHOLD: int = 2

@export var DEBUG_LOG: bool = true

func _ready() -> void:
	rng.randomize()

	var viewport_size: Vector2 = get_viewport().get_visible_rect().size
	viewport_width = viewport_size.x
	viewport_height = viewport_size.y
	
	print("WIDTH = ", viewport_width, " HEIGHT = ", viewport_height)

	

	var world_left: float = LEFT_WALL_X
	var world_right: float = RIGHT_WALL_X

	if USE_FIXED_WORLD_WIDTH:
		world_right = world_left + max(0.0, FIXED_WORLD_WIDTH)
	else:
		var screens_width: float = max(1, WORLD_SCREENS) * viewport_width
		world_right = world_left + screens_width

	min_center_x = world_left + HORIZONTAL_WORLD_MARGIN
	max_center_x = world_right - HORIZONTAL_WORLD_MARGIN

	if max_center_x <= min_center_x:
		var safe_margin_try: float = max(8.0, viewport_width * 0.1)
		min_center_x = world_left + safe_margin_try
		max_center_x = world_right - safe_margin_try
		if DEBUG_LOG:
			print("WORLD_MARGIN_ADJUSTED: used safe_margin_try=", safe_margin_try)

	if DEBUG_LOG:
		print("WORLD_BOUNDS: world_left=", world_left, " world_right=", world_right,
			" min_center_x=", min_center_x, " max_center_x=", max_center_x,
			" viewport_width=", viewport_width)

	var start_x: float = clamp(min_center_x + 200.0, min_center_x, max_center_x)
	var start_y: float = viewport_height - 200.0
	if player:
		player.global_position = Vector2(start_x, start_y)
	else:
		push_error("Level.gd: player node not found at $Player")

	difficulty = clamp(DIFFICULTY_START, 0.0, DIFFICULTY_MAX)

	for child in platforms_root.get_children():
		child.queue_free()
	platforms.clear()

	_create_initial_platforms()

func _physics_process(_delta: float) -> void:
	_update_platforms_around_player()

# --- FIX: безопасно читаем export-поля Player.gd через get() ---
func _get_player_param_float(param_name: String, fallback_value: float) -> float:
	if player == null:
		return fallback_value
	var v: Variant = player.get(param_name)
	if v == null:
		return fallback_value
	return float(v)

func _max_horizontal_reach(start_surface_y: float, target_surface_y: float, v_jump: float, g: float, v_x: float) -> float:
	var delta_y: float = target_surface_y - start_surface_y
	var disc: float = v_jump * v_jump + 2.0 * g * delta_y
	if disc < 0.0:
		return 0.0
	var t: float = (-v_jump + sqrt(disc)) / g
	return abs(v_x) * t

func _can_place_platform_at(pos: Vector2, segments: int) -> bool:
	var half_new_x: float = float(segments) * TILE_SIZE * 0.5
	for p in platforms:
		if not p:
			continue
		var existing_segments: int = max(1, int(round(p.scale.x)))
		var half_ex_x: float = float(existing_segments) * TILE_SIZE * 0.5
		var dx: float = abs(pos.x - p.global_position.x)
		var dy: float = abs(pos.y - p.global_position.y)
		var min_allowed_dx: float = half_new_x + half_ex_x + MIN_EDGE_GAP
		var min_allowed_dy: float = PLATFORM_HEIGHT + MIN_VERTICAL_GAP
		if dx < min_allowed_dx and dy < min_allowed_dy:
			return false
	return true

func _create_initial_platforms() -> void:
	var start_platform_pos: Vector2 = player.global_position + Vector2(0.0, 80.0)
	var initial_segments: int = 4
	_spawn_main_platform_at(start_platform_pos, initial_segments)

	going_right = true
	for _i in range(MIN_TOTAL_PLATFORMS - 1):
		_spawn_next_step()

func _spawn_main_platform_at(pos: Vector2, segments: int) -> Node2D:
	var clamped_segments: int = clamp(segments, MAIN_MIN_SEGMENTS, MAIN_MAX_SEGMENTS)
	var adjusted_pos: Vector2 = pos
	var attempts: int = 0
	while attempts < 6 and not _can_place_platform_at(adjusted_pos, clamped_segments):
		adjusted_pos.y -= PLATFORM_HEIGHT + MIN_VERTICAL_GAP
		attempts += 1

	var p: Node2D = platform_scene.instantiate()
	platforms_root.add_child(p)
	p.global_position = adjusted_pos
	p.scale.x = float(clamped_segments)
	platforms.append(p)

	last_main_segments = clamped_segments
	last_main_pos = adjusted_pos

	if DEBUG_LOG:
		print("Spawn main platform at ", adjusted_pos, " seg=", clamped_segments, " attempts=", attempts)
	return p

func _spawn_next_step() -> void:
	difficulty = clamp(difficulty + DIFFICULTY_PER_STEP, 0.0, DIFFICULTY_MAX)

	var seg_main: int = rng.randi_range(MAIN_MIN_SEGMENTS, MAIN_MAX_SEGMENTS)
	var half_prev: float = float(last_main_segments) * TILE_SIZE * 0.5
	var half_new: float = float(seg_main) * TILE_SIZE * 0.5

	var new_y: float = last_main_pos.y - DY_STEP

	var start_surface_y: float = last_main_pos.y - PLATFORM_HEIGHT * 0.5
	var target_surface_y: float = new_y - PLATFORM_HEIGHT * 0.5

	var p_jump: float = _get_player_param_float("JUMP_VELOCITY", -960.0)
	var p_grav: float = _get_player_param_float("GRAVITY", 2600.0)
	var p_speed: float = _get_player_param_float("MOVE_SPEED", 260.0)

	var reach: float = _max_horizontal_reach(start_surface_y, target_surface_y, p_jump, p_grav, p_speed)
	if DEBUG_LOG:
		print("reach=", reach, " start_y=", start_surface_y, " target_y=", target_surface_y)

	var max_edge_gap_physical: float = max(0.0, reach - SAFE_MARGIN_X - half_new)

	var cur_min_pct: float = lerp(GAP_MIN_PCT_EASY, GAP_MIN_PCT_HARD, difficulty)
	var cur_max_pct: float = lerp(GAP_MAX_PCT_EASY, GAP_MAX_PCT_HARD, difficulty)
	if cur_max_pct < cur_min_pct:
		var tmp: float = cur_min_pct
		cur_min_pct = cur_max_pct
		cur_max_pct = tmp

	var desired_min: float = max(0.0, cur_min_pct * reach)
	var desired_max: float = max(0.0, cur_max_pct * reach)

	var edge_gap_min_from_desired: float = max(0.0, desired_min - half_new)
	var edge_gap_max_from_desired: float = max(0.0, desired_max - half_new)

	var max_allowed_gap: float = min(MAX_EDGE_GAP, max_edge_gap_physical)
	max_allowed_gap = min(max_allowed_gap, MAX_MAIN_EDGE_GAP_ABS)

	var allowed_min: float = max(edge_gap_min_from_desired, MIN_MAIN_EDGE_GAP_ABS)
	var allowed_max: float = min(edge_gap_max_from_desired, max_allowed_gap)

	var found: bool = false
	var chosen_edge_gap: float = 0.0
	var chosen_seg: int = seg_main
	var attempts: int = 0
	var max_attempts: int = 12

	while not found and attempts < max_attempts:
		half_new = float(chosen_seg) * TILE_SIZE * 0.5
		max_edge_gap_physical = max(0.0, reach - SAFE_MARGIN_X - half_new)

		edge_gap_min_from_desired = max(0.0, desired_min - half_new)
		edge_gap_max_from_desired = max(0.0, desired_max - half_new)

		max_allowed_gap = min(MAX_EDGE_GAP, max_edge_gap_physical)
		max_allowed_gap = min(max_allowed_gap, MAX_MAIN_EDGE_GAP_ABS)

		allowed_min = max(edge_gap_min_from_desired, MIN_MAIN_EDGE_GAP_ABS)
		allowed_max = min(edge_gap_max_from_desired, max_allowed_gap)

		if allowed_max < allowed_min:
			if chosen_seg > MAIN_MIN_SEGMENTS:
				chosen_seg -= 1
				attempts += 1
				continue
			else:
				break

		var candidates: Array[float] = [(allowed_min + allowed_max) * 0.5, allowed_min, allowed_max]

		for c in candidates:
			var dir_x: float = 1.0 if going_right else -1.0
			var tentative_x: float = last_main_pos.x + dir_x * (half_prev + half_new + c)
			var clamped_x: float = clamp(tentative_x, min_center_x, max_center_x)
			var candidate_pos: Vector2 = Vector2(clamped_x, new_y)

			if clamped_x != tentative_x:
				wall_clamp_count += 1
				if DEBUG_LOG:
					print("WALL_CLAMP candidate try#", wall_clamp_count,
						" tentative_x=", tentative_x, " clamped_x=", clamped_x,
						" going_right=", going_right)
				if wall_clamp_count >= WALL_CLAMP_THRESHOLD:
					going_right = not going_right
					wall_clamp_count = 0
					if DEBUG_LOG:
						print("WALL_FLIP -> now going_right=", going_right)
					break
				continue

			if _can_place_platform_at(candidate_pos, chosen_seg):
				found = true
				chosen_edge_gap = c
				break

		if not found:
			if chosen_seg > MAIN_MIN_SEGMENTS:
				chosen_seg -= 1
				attempts += 1
				continue
			else:
				break

	if found:
		var p: Node2D = platform_scene.instantiate()
		platforms_root.add_child(p)

		var dir_x_final: float = 1.0 if going_right else -1.0
		var tentative_x_final: float = last_main_pos.x + dir_x_final * (half_prev + float(chosen_seg) * TILE_SIZE * 0.5 + chosen_edge_gap)
		var clamped_x_final: float = clamp(tentative_x_final, min_center_x, max_center_x)

		var final_pos: Vector2 = Vector2(clamped_x_final, new_y)

		p.global_position = final_pos
		p.scale.x = float(chosen_seg)
		platforms.append(p)

		last_main_segments = chosen_seg
		last_main_pos = final_pos

		if DEBUG_LOG:
			print("Placed main at ", final_pos, " seg=", chosen_seg, " edge_gap=", chosen_edge_gap, " reach=", reach)

		_spawn_decoys_around(p.global_position, chosen_seg)
		return

	# fallback
	var fallback_pos: Vector2 = Vector2(clamp(last_main_pos.x, min_center_x, max_center_x), new_y)
	var main_platform: Node2D = _spawn_main_platform_at(fallback_pos, seg_main)
	_spawn_decoys_around(main_platform.global_position, seg_main)

func _spawn_decoys_around(main_pos: Vector2, main_segments: int) -> void:
	var num_decoys: int = rng.randi_range(2, 3)
	if num_decoys <= 0:
		return

	for _i in range(num_decoys):
		var seg: int = rng.randi_range(DECOY_MIN_SEGMENTS, DECOY_MAX_SEGMENTS)
		var side: float = 1.0 if rng.randf() < 0.5 else -1.0
		var extra_offset: float = rng.randf_range(DECOY_OFFSET_X_MIN, DECOY_OFFSET_X_MAX)

		var half_main: float = float(main_segments) * TILE_SIZE * 0.5
		var half_decoy: float = float(seg) * TILE_SIZE * 0.5

		var decoy_center_x: float = main_pos.x + side * (half_main + half_decoy + extra_offset)
		decoy_center_x = clamp(decoy_center_x, min_center_x, max_center_x)

		var offset_y: float = rng.randf_range(-2.0 * PLATFORM_HEIGHT, 2.0 * PLATFORM_HEIGHT)
		var decoy_pos: Vector2 = Vector2(decoy_center_x, main_pos.y + offset_y)

		if not _can_place_platform_at(decoy_pos, seg):
			continue

		var decoy: Node2D = platform_scene.instantiate()
		platforms_root.add_child(decoy)
		decoy.global_position = decoy_pos
		decoy.scale.x = float(seg)
		platforms.append(decoy)

func _update_platforms_around_player() -> void:
	var player_y: float = player.global_position.y

	var remove_below: float = player_y + viewport_height
	for p in platforms.duplicate():
		if p.global_position.y > remove_below:
			platforms.erase(p)
			p.queue_free()

	var upper_limit: float = player_y - viewport_height
	while platforms.size() < MIN_TOTAL_PLATFORMS or last_main_pos.y > upper_limit:
		_spawn_next_step()


--- FILE: D:\YandexDisk\Projects\Runner\Godot\scripts\Platform.gd ---

extends StaticBody2D
# Platform.gd — УЛУЧШЕННАЯ ГЕНЕРАЦИЯ МОНЕТ (как у тебя)

@export var size: Vector2 = Vector2(64, 64)
@export var coin_spawn_chance: float = 0.8
@export var coin_height_offset: float = 80.0

@onready var collision_shape: CollisionShape2D = $CollisionShape2D

var coin_scene: PackedScene
var rng: RandomNumberGenerator = RandomNumberGenerator.new()

func _ready() -> void:
	rng.randomize()

	coin_scene = preload("res://Coin.tscn")

	if collision_shape != null:
		var rect_shape := RectangleShape2D.new()
		rect_shape.size = size
		collision_shape.shape = rect_shape
		collision_shape.one_way_collision = true
		collision_shape.one_way_collision_margin = 10.0

	# Платформа на слое 1
	set_collision_layer_value(1, true)
	for i in range(2, 33):
		set_collision_layer_value(i, false)

	if coin_scene != null and coin_spawn_chance > 0.0:
		if rng.randf() < coin_spawn_chance:
			await get_tree().create_timer(0.1).timeout
			_spawn_coin_above()

	queue_redraw()

func _spawn_coin_above() -> void:
	if coin_scene == null:
		return

	var coin := coin_scene.instantiate()

	var root = get_tree().current_scene
	if root:
		root.add_child(coin)

		var platform_center := global_position
		var coin_pos := platform_center + Vector2(0.0, -coin_height_offset)
		coin.global_position = coin_pos

		print("✅ Platform spawned coin at: ", coin_pos)

func _draw() -> void:
	var rect := Rect2(-size * 0.5, size)
	draw_rect(rect, Color(0.1, 0.9, 0.2, 1.0))


--- FILE: D:\YandexDisk\Projects\Runner\Godot\scripts\Player.gd ---

extends CharacterBody2D
# ============================================================================
# Player.gd — Улучшенная логика смерти: падение на 2 экрана от последней платформы
# ----------------------------------------------------------------------------
# - Смерть наступает, если игрок упал на 2 экрана ниже последней безопасной позиции
# - Резерв: абсолютный предел FALL_LIMIT_Y_ABSOLUTE
# - Защита от ложных срабатываний: условие должно держаться FALL_DEATH_HOLD_SECONDS
# - DEBUG вывод можно отключить
# ============================================================================

@export var GRAVITY: float = 2000.0
@export var MOVE_SPEED: float = 350.0
@export var JUMP_VELOCITY: float = -960.0
@export var DEFAULT_MOVE_DIR: float = 1.0

@export var JUMP_COOLDOWN: float = 0.08
@export var USE_PIXEL_SNAP: bool = true

# Камера / абсолютные параметры
@export var DEATH_SCREENS: float = 2.0  # Количество экранов ниже последней безопасной позиции для смерти
@export var FALL_LIMIT_Y_ABSOLUTE: float = 15000.0

# Сколько секунд условие должно держаться, прежде чем вызвать _die()
@export var FALL_DEATH_HOLD_SECONDS: float = 0.5

# Включить/выключить подробный лог
@export var DEBUG: bool = true

@export_file("*.tscn") var main_menu_scene: String = "res://MainMenu.tscn"

# ----------------------------------------------------------------------------
# Ресурсы героев (настраиваются в инспекторе)
# ----------------------------------------------------------------------------
@export var frames_default: SpriteFrames
@export var frames_monster: SpriteFrames
@export var frames_red: SpriteFrames
@export var frames_blue: SpriteFrames
@export var frames_orange: SpriteFrames

var move_dir: float = 0.0
var jump_timer: float = 0.0
var _was_touching_floor: bool = false

# Кастом-аватар
var _custom_tex_up: Texture2D = null
var _custom_tex_down: Texture2D = null
var _using_custom_avatar: bool = false
const CUSTOM_AVATAR_TARGET_SIZE_PX: int = 128

# Таймеры для "удержания" условия смерти
var _fall_death_timer: float = 0.0

# Последняя безопасная позиция Y (где стоял на платформе)
var last_safe_y: float = 0.0

@onready var cam: Camera2D = $Camera2D
@onready var anim: AnimatedSprite2D = $AnimatedSprite2D
@onready var custom_sprite: Sprite2D = $CustomAvatarSprite

func _ready() -> void:
	if DEBUG:
		print("PLAYER READY")
	# Коллизии: игрок = слой 1, реагируем на платформы (1) и монеты (2)
	set_collision_layer_value(1, true)
	set_collision_mask_value(1, true)
	set_collision_mask_value(2, true)
	for i in range(3, 33):
		set_collision_mask_value(i, false)

	if abs(DEFAULT_MOVE_DIR) < 0.001:
		DEFAULT_MOVE_DIR = 1.0
	move_dir = DEFAULT_MOVE_DIR

	_was_touching_floor = is_on_floor()
	
	# ИНИЦИАЛИЗИРУЕМ ПОСЛЕДНЮЮ БЕЗОПАСНУЮ ПОЗИЦИЮ
	last_safe_y = global_position.y
	if DEBUG:
		print("🎯 Начальная безопасная позиция: ", last_safe_y)

	if cam:
		cam.make_current()

	_apply_visual_mode()

func _apply_visual_mode() -> void:
	_using_custom_avatar = bool(GameState.get_use_custom_avatar())

	if _using_custom_avatar:
		var ok: bool = _load_custom_avatar_textures()
		if ok:
			if custom_sprite:
				custom_sprite.visible = true
			if anim:
				anim.visible = false
			if DEBUG:
				print("✅ Custom avatar enabled")
			return
		else:
			_using_custom_avatar = false
			GameState.set_use_custom_avatar(false)
			if DEBUG:
				print("⚠ Custom avatar enabled but images missing -> fallback")

	if custom_sprite:
		custom_sprite.visible = false
	if anim:
		anim.visible = true

	var hero_id: String = str(GameState.get_selected_hero_id()).strip_edges()
	if hero_id == "":
		hero_id = "default"

	var target_frames: SpriteFrames = null
	match hero_id:
		"monster": target_frames = frames_monster
		"red":     target_frames = frames_red
		"blue":    target_frames = frames_blue
		"orange":  target_frames = frames_orange
		_:         target_frames = frames_default

	if target_frames:
		anim.sprite_frames = target_frames

	if anim and anim.sprite_frames != null and anim.sprite_frames.has_animation("JUMP"):
		anim.stop()
		anim.animation = "JUMP"
		anim.frame = 0

func _load_custom_avatar_textures() -> bool:
	_custom_tex_up = null
	_custom_tex_down = null

	var up_path: String = str(GameState.get_custom_avatar_up_path()).strip_edges()
	var down_path: String = str(GameState.get_custom_avatar_down_path()).strip_edges()

	if up_path == "":
		up_path = "user://custom_jump_up.png"
	if down_path == "":
		down_path = "user://custom_jump_down.png"

	if not FileAccess.file_exists(up_path) or not FileAccess.file_exists(down_path):
		return false

	var img_up: Image = Image.new()
	if img_up.load(up_path) != OK:
		return false
	var img_down: Image = Image.new()
	if img_down.load(down_path) != OK:
		return false

	if img_up.get_format() != Image.FORMAT_RGBA8:
		img_up.convert(Image.FORMAT_RGBA8)
	if img_down.get_format() != Image.FORMAT_RGBA8:
		img_down.convert(Image.FORMAT_RGBA8)

	var fitted_up: Image = _fit_image_into_square(img_up, CUSTOM_AVATAR_TARGET_SIZE_PX)
	var fitted_down: Image = _fit_image_into_square(img_down, CUSTOM_AVATAR_TARGET_SIZE_PX)

	var up_tex: ImageTexture = ImageTexture.new()
	var down_tex: ImageTexture = ImageTexture.new()
	up_tex.set_image(fitted_up)
	down_tex.set_image(fitted_down)

	_custom_tex_up = up_tex
	_custom_tex_down = down_tex

	if custom_sprite:
		custom_sprite.texture = _custom_tex_up

	return true

func _input(event: InputEvent) -> void:
	if event is InputEventMouseButton and event.pressed:
		if event.button_index == MOUSE_BUTTON_LEFT:
			var center: float = get_viewport_rect().size.x * 0.5
			move_dir = -1.0 if event.position.x < center else 1.0
	elif event is InputEventScreenTouch and event.pressed:
		var center: float = get_viewport_rect().size.x * 0.5
		move_dir = -1.0 if event.position.x < center else 1.0

func _physics_process(delta: float) -> void:
	velocity.y += GRAVITY * delta

	var key_dir: float = 0.0
	if Input.is_action_pressed("move_left"):
		key_dir -= 1.0
	if Input.is_action_pressed("move_right"):
		key_dir += 1.0
	if key_dir != 0.0:
		move_dir = key_dir

	velocity.x = move_dir * MOVE_SPEED
	move_and_slide()

	if USE_PIXEL_SNAP:
		global_position = global_position.round()

	jump_timer = max(0.0, jump_timer - delta)

	var touching_floor_now: bool = _check_floor_collision()
	
	# ОБНОВЛЯЕМ ПОСЛЕДНЮЮ БЕЗОПАСНУЮ ПОЗИЦИЮ ПРИ КАСАНИИ ПЛАТФОРМЫ
	if touching_floor_now:
		last_safe_y = global_position.y
		if DEBUG:
			print("✅ Обновлена безопасная позиция: ", last_safe_y)
	
	if touching_floor_now and not _was_touching_floor and jump_timer <= 0.0:
		velocity.y = JUMP_VELOCITY
		jump_timer = JUMP_COOLDOWN
		if DEBUG:
			print("🔄 Последний прыжок с позиции: ", last_safe_y)

	_was_touching_floor = touching_floor_now

	_update_jump_visual()

	# Проверка смерти с удержанием порога (debounce)
	_process_fall_death(delta)

func _update_jump_visual() -> void:
	var going_up: bool = (velocity.y < 0.0)

	if anim:
		anim.flip_h = (move_dir < 0.0)
	if custom_sprite:
		custom_sprite.flip_h = (move_dir < 0.0)

	if _using_custom_avatar:
		if custom_sprite and _custom_tex_up != null and _custom_tex_down != null:
			custom_sprite.texture = _custom_tex_up if going_up else _custom_tex_down
		return

	if anim == null or anim.sprite_frames == null:
		return
	if not anim.sprite_frames.has_animation("JUMP"):
		return

	anim.stop()
	anim.animation = "JUMP"
	anim.frame = 0 if going_up else 1

# ----------------------------------------------------------------------------
# Обработка смерти с удержанием порога (debounce)
# ----------------------------------------------------------------------------
func _process_fall_death(delta: float) -> void:
	if cam == null:
		# Если камеры нет — используем только абсолютный лимит
		if global_position.y > FALL_LIMIT_Y_ABSOLUTE:
			_fall_death_timer += delta
		else:
			_fall_death_timer = 0.0

		if _fall_death_timer >= FALL_DEATH_HOLD_SECONDS:
			if DEBUG:
				print("DIE_REASON: absolute_limit held for", _fall_death_timer, "pos_y=", global_position.y)
			_die()
		return

	# Вычисляем видимую высоту экрана с учётом зума
	var viewport_size: Vector2 = get_viewport().get_visible_rect().size
	var viewport_height: float = max(1.0, viewport_size.y)

	var zoom_y: float = float(cam.zoom.y)
	var visible_height: float = viewport_height * zoom_y

	# 🔴 ИЗМЕНЕНИЕ: Используем last_safe_y вместо позиции камеры
	# Смерть наступает, если игрок упал на 2 экрана ниже последней безопасной позиции
	var death_y: float = last_safe_y + visible_height * DEATH_SCREENS

	# Лог для отладки
	if DEBUG:
		print("DEATH_CHECK: player_y=", global_position.y,
			" last_safe_y=", last_safe_y,
			" visible_height=", visible_height,
			" DEATH_SCREENS=", DEATH_SCREENS,
			" death_y=", death_y)

	# Условие: игрок ниже death_y (2 экрана от последней безопасной позиции)
	var fall_from_safe_condition: bool = (global_position.y > death_y)
	
	# Условие абсолютного лимита
	var absolute_condition: bool = (global_position.y > FALL_LIMIT_Y_ABSOLUTE)

	# Если хоть одно условие истинно — увеличиваем таймер удержания
	if fall_from_safe_condition or absolute_condition:
		_fall_death_timer += delta
		if DEBUG:
			if fall_from_safe_condition:
				print("FALL_TIMER: fall_from_safe_condition true, timer=", _fall_death_timer,
					  " (fallen: ", global_position.y - last_safe_y, " pixels)")
			if absolute_condition:
				print("FALL_TIMER: absolute_condition true, timer=", _fall_death_timer)
	else:
		# Сбрасываем таймер при возврате в безопасную зону
		if _fall_death_timer > 0.0 and DEBUG:
			print("FALL_TIMER: reset (player returned above threshold) timer was=", _fall_death_timer)
		_fall_death_timer = 0.0

	# Если условие держалось достаточно долго — умираем
	if _fall_death_timer >= FALL_DEATH_HOLD_SECONDS:
		if DEBUG:
			print("DIE_REASON: held threshold for", _fall_death_timer,
				  " player_y=", global_position.y,
				  " (fallen ", global_position.y - last_safe_y, " pixels from last safe position)")
		_die()

# ----------------------------------------------------------------------------
# Смерть / смена сцены
# ----------------------------------------------------------------------------
func _die() -> void:
	print("🚨 Player DIED! pos_y:", global_position.y)

	# В редакторе — перезагрузим сцену для удобства
	if Engine.is_editor_hint():
		get_tree().reload_current_scene()
		return

	# Регистрируем результат и уходим в меню
	GameState.register_run_finished()

	if main_menu_scene != "" and main_menu_scene != null:
		var err: int = get_tree().change_scene_to_file(main_menu_scene)
		if err != OK:
			push_error("Player.gd: cannot load main menu: " + main_menu_scene)
			get_tree().reload_current_scene()
	else:
		get_tree().reload_current_scene()

func _check_floor_collision() -> bool:
	var count: int = get_slide_collision_count()
	if count == 0:
		return is_on_floor()
	for i in range(count):
		var c = get_slide_collision(i)
		if c and c.get_normal().y < -0.7:
			return true
	return false

func _fit_image_into_square(src: Image, target_size: int) -> Image:
	var src_w: int = src.get_width()
	var src_h: int = src.get_height()

	if src_w <= 0 or src_h <= 0:
		var empty: Image = Image.create(target_size, target_size, false, Image.FORMAT_RGBA8)
		empty.fill(Color(0,0,0,0))
		return empty

	var dst: Image = Image.create(target_size, target_size, false, Image.FORMAT_RGBA8)
	dst.fill(Color(0, 0, 0, 0))

	var resized: Image = src.duplicate()
	if resized.get_format() != Image.FORMAT_RGBA8:
		resized.convert(Image.FORMAT_RGBA8)

	var scale: float = min(float(target_size) / float(src_w), float(target_size) / float(src_h))
	var new_w: int = max(1, int(round(float(src_w) * scale)))
	var new_h: int = max(1, int(round(float(src_h) * scale)))

	resized.resize(new_w, new_h, Image.INTERPOLATE_LANCZOS)

	var x: int = int((target_size - new_w) / 2)
	var y: int = int((target_size - new_h) / 2)

	dst.blit_rect(resized, Rect2i(0, 0, new_w, new_h), Vector2i(x, y))
	return dst


--- FILE: D:\YandexDisk\Projects\Runner\Godot\wall\data\WallData.gd ---

extends Node
class_name WallData
# ============================================================================
# WallData.gd
# Хранилище данных стены (локально, без онлайна)
# ============================================================================
# - хранит сегменты
# - знает кто купил
# - позже легко подключается к JSON / серверу
# ============================================================================

# segment_id -> { owner: String }
var segments: Dictionary = {}

# ---------------------------------------------------------------------------

func has_segment(id: String) -> bool:
	return segments.has(id)

# ---------------------------------------------------------------------------

func get_segment(id: String) -> Dictionary:
	if not segments.has(id):
		segments[id] = {
			"owner": ""
		}
	return segments[id]

# ---------------------------------------------------------------------------

func buy_side(segment_id: String, buyer_uid: String) -> bool:
	var seg := get_segment(segment_id)

	# уже куплено
	if str(seg.get("owner", "")) != "":
		return false

	# покупаем
	seg["owner"] = buyer_uid
	segments[segment_id] = seg
	return true

# ---------------------------------------------------------------------------

func reset() -> void:
	segments.clear()


--- FILE: D:\YandexDisk\Projects\Runner\Godot\wall\segment\WallSegment.gd ---

extends Node2D
# ============================================================================
# WallSegment.gd
# Один сегмент стены (48x48)
# Визуал: Sprite2D
# Взаимодействие: Area2D
# Автоматическая анимация: показ сторон (front/left/right/top)
# ============================================================================

@export var segment_id: String = ""

## Полное время показа всех четырёх сторон (секунды).
## По умолчанию 60.0 = каждая сторона ~15 секунд.
@export var showcase_duration: float = 60.0

@onready var area: Area2D = $Area2D
@onready var sprite: Sprite2D = $Sprite2D

var wall_data: WallData = null

# Порядок сторон для витрины
const SIDE_SEQUENCE: Array[String] = ["front", "left", "right", "top"]

# Внутренние переменные для анимации
var _time_accum: float = 0.0
var _current_side_index: int = 0
var _base_rotation: float = 0.0


# ---------------------------------------------------------------------------
# ОБЯЗАТЕЛЬНЫЙ МЕТОД — его вызывает wall.gd
# ---------------------------------------------------------------------------

func setup(id: String, _side: String, data: WallData) -> void:
	segment_id = id
	wall_data = data
	_update_visual_state()
	_apply_side_visuals()


func _ready() -> void:
	print("🎲 WallSegment ready:", segment_id)
	
	# Подключаем клики
	if area and not area.input_event.is_connected(_on_area_input):
		area.input_event.connect(_on_area_input)

	_update_visual_state()
	_apply_side_visuals()
	
	# Добавляем небольшое случайное смещение времени для разнообразия
	_time_accum = randf() * showcase_duration


func _process(delta: float) -> void:
	_update_showcase(delta)


# ---------------------------------------------------------------------------

func _on_area_input(
	viewport: Viewport,
	event: InputEvent,
	shape_idx: int
) -> void:
	if event is InputEventMouseButton and event.pressed:
		_try_buy()


func _try_buy() -> void:
	if wall_data == null:
		push_warning("WallSegment: wall_data == null")
		return

	if not Engine.has_singleton("GameState"):
		push_warning("GameState singleton not found")
		return

	var buyer_uid: String = GameState.player_uid
	var ok: bool = wall_data.buy_side(segment_id, buyer_uid)

	if ok:
		print("✅ Куплено:", segment_id)
	else:
		print("⛔ Уже куплено:", segment_id)

	_update_visual_state()


func _update_visual_state() -> void:
	if sprite == null:
		return

	# БАЗОВОЕ СОСТОЯНИЕ
	if wall_data == null:
		sprite.modulate = Color(0.3, 0.3, 0.3)
		return

	var seg := wall_data.get_segment(segment_id)
	if seg == null:
		sprite.modulate = Color(0.3, 0.3, 0.3)
		return

	var owner := str(seg.get("owner", ""))

	if owner == "":
		sprite.modulate = Color(0.4, 0.4, 0.4) # свободен
	else:
		sprite.modulate = Color(0.1, 0.8, 0.2) # куплен


# ---------------------------------------------------------------------------
# Система показа сторон (front / left / right / top)
# ---------------------------------------------------------------------------

func _update_showcase(delta: float) -> void:
	if showcase_duration <= 0.0 or sprite == null:
		return

	_time_accum += delta
	if _time_accum >= showcase_duration:
		_time_accum = fmod(_time_accum, showcase_duration)

	var t := _time_accum / showcase_duration
	var side_count := SIDE_SEQUENCE.size()
	if side_count == 0:
		return

	var phase_float := t * float(side_count)
	var phase := int(phase_float) % side_count

	if phase != _current_side_index:
		_current_side_index = phase
		_apply_side_visuals()

	# Плавное покачивание для текущей стороны
	var local_phase := phase_float - float(phase) # [0, 1)
	var wobble := sin(local_phase * TAU) * 0.03
	sprite.rotation = _base_rotation + wobble


func _apply_side_visuals() -> void:
	if sprite == null:
		return

	var base_color := _get_base_color()
	var side := SIDE_SEQUENCE[_current_side_index] if _current_side_index < SIDE_SEQUENCE.size() else "front"

	# Визуальные трансформации для каждой стороны (фейковый 3D куб)
	match side:
		"front":
			sprite.position = Vector2.ZERO
			sprite.scale = Vector2.ONE
			sprite.modulate = base_color
			_base_rotation = 0.0
		"left":
			sprite.position = Vector2(-3, 0)
			sprite.scale = Vector2(0.94, 1.0)
			sprite.modulate = base_color * Color(0.9, 0.9, 1.0)
			_base_rotation = deg_to_rad(-8.0)
		"right":
			sprite.position = Vector2(3, 0)
			sprite.scale = Vector2(0.94, 1.0)
			sprite.modulate = base_color * Color(0.9, 0.9, 1.0)
			_base_rotation = deg_to_rad(8.0)
		"top":
			sprite.position = Vector2(0, -3)
			sprite.scale = Vector2(1.0, 0.9)
			sprite.modulate = base_color * Color(1.05, 1.05, 1.05)
			_base_rotation = 0.0
		_:
			sprite.position = Vector2.ZERO
			sprite.scale = Vector2.ONE
			sprite.modulate = base_color
			_base_rotation = 0.0

	sprite.rotation = _base_rotation


func _get_base_color() -> Color:
	# Базовый цвет зависит от владения
	if wall_data == null:
		return Color(0.3, 0.3, 0.3)

	var seg := wall_data.get_segment(segment_id)
	if seg == null:
		return Color(0.3, 0.3, 0.3)

	var owner := str(seg.get("owner", ""))
	if owner == "":
		return Color(0.4, 0.4, 0.4) # свободен
	else:
		return Color(0.1, 0.8, 0.2) # куплен


--- FILE: D:\YandexDisk\Projects\Runner\Godot\wall\segment\WallSegment.tscn ---

[gd_scene load_steps=4 format=3 uid="uid://ddaj86ldrt5dv"]

[ext_resource type="Script" uid="uid://vefl2li33f3i" path="res://wall/segment/WallSegment.gd" id="1_6wo4f"]
[ext_resource type="Texture2D" uid="uid://ctja12icu7s5l" path="res://wall/textures/wall_segment.png" id="2_16rbj"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_6wo4f"]
size = Vector2(48, 48)

[node name="WallSegment" type="Node2D"]
script = ExtResource("1_6wo4f")

[node name="Sprite2D" type="Sprite2D" parent="."]
z_index = 10
texture = ExtResource("2_16rbj")
centered = true
position = Vector2(0, 0)
scale = Vector2(1, 1)

[node name="Area2D" type="Area2D" parent="."]

[node name="CollisionShape2D" type="CollisionShape2D" parent="Area2D"]
shape = SubResource("RectangleShape2D_6wo4f")



--- FILE: D:\YandexDisk\Projects\Runner\Godot\wall\wall.gd ---

extends Node2D
# ============================================================================
# wall.gd
# Генерация простой сетки кубов 48x48
# ============================================================================
# - работает только с Node2D / Sprite2D / Area2D
# - создаёт сетку сегментов
# - сам ничего не рисует
# ============================================================================
# Проверено: Godot 4.x
# ============================================================================

@export var segment_size: int = 48
@export var segments_x: int = 16
@export var segments_y: int = 8

@onready var segment_scene: PackedScene = preload("res://wall/segment/WallSegment.tscn")

var wall_data: WallData


func _ready() -> void:
	print("🧱 Wall ready")

	# Локальное хранилище данных стены (без онлайна).
	wall_data = WallData.new()
	add_child(wall_data)

	_generate_wall()


func _generate_wall() -> void:
	print("🧩 Generating wall...")
	clear_wall()

	# Центрируем стену относительно позиции Wall узла
	var total_width: float = segments_x * segment_size
	var total_height: float = segments_y * segment_size
	var start_x: float = -total_width * 0.5 + segment_size * 0.5
	var start_y: float = -total_height * 0.5 + segment_size * 0.5

	var created_count := 0

	for y in range(segments_y):
		for x in range(segments_x):
			var segment := segment_scene.instantiate()
			if segment == null:
				continue

			add_child(segment)

			var pos := Vector2(
				start_x + x * segment_size,
				start_y + y * segment_size
			)
			segment.position = pos

			var id := "%d_%d" % [x, y]

			if segment.has_method("setup"):
				segment.setup(id, "front", wall_data)
			else:
				segment.segment_id = id

			created_count += 1

	print("✅ Created", created_count, "segments (grid:", segments_x, "x", segments_y, ")")


func clear_wall() -> void:
	for child in get_children():
		if child is WallData:
			continue
		child.queue_free()


--- FILE: D:\YandexDisk\Projects\Runner\Godot\wall\wall.tscn ---

[gd_scene load_steps=2 format=3 uid="uid://dpol13adfo7g3"]

[ext_resource type="Script" uid="uid://bhoujd3rj3ox8" path="res://wall/wall.gd" id="1_sef87"]

[node name="Wall" type="Node2D"]
script = ExtResource("1_sef87")

