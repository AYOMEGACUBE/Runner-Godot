PROJECT FULL DUMP: 2026-02-13T11:14:11.5486195+03:00

=== PROJECT TREE (ASCII) ===

Godot/    (res://)
├── .cursor/    (res://.cursor)
│   └── rules/    (res://.cursor/rules)
├── .git/    (res://.git)
│   ├── hooks/    (res://.git/hooks)
│   │   ├── applypatch-msg.sample    (other)
│   │   ├── commit-msg.sample    (other)
│   │   ├── fsmonitor-watchman.sample    (other)
│   │   ├── post-update.sample    (other)
│   │   ├── pre-applypatch.sample    (other)
│   │   ├── pre-commit.sample    (other)
│   │   ├── pre-merge-commit.sample    (other)
│   │   ├── prepare-commit-msg.sample    (other)
│   │   ├── pre-push.sample    (other)
│   │   ├── pre-rebase.sample    (other)
│   │   ├── pre-receive.sample    (other)
│   │   ├── push-to-checkout.sample    (other)
│   │   ├── sendemail-validate.sample    (other)
│   │   └── update.sample    (other)
│   ├── info/    (res://.git/info)
│   │   └── exclude    (other)
│   ├── logs/    (res://.git/logs)
│   │   ├── refs/    (res://.git/logs/refs)
│   │   │   └── heads/    (res://.git/logs/refs/heads)
│   │   │       ├── backup-before-refactor    (other)
│   │   │       └── master    (other)
│   │   └── HEAD    (other)
│   ├── objects/    (res://.git/objects)
│   │   ├── 02/    (res://.git/objects/02)
│   │   │   └── affec6c2e474123eed44d339d3e7fc426276f6    (other)
│   │   ├── 04/    (res://.git/objects/04)
│   │   │   ├── 713811d96c1a5d68f9a2bc16a154c267cd8f90    (other)
│   │   │   ├── 7b7a3b934a5c84b3c81f036892ec8d4cfde733    (other)
│   │   │   └── 7fc0d6053654cd26252295cba2c7bba941d3b5    (other)
│   │   ├── 05/    (res://.git/objects/05)
│   │   │   └── 98c62c0f456b6f13a907b95209b0b72276fca6    (other)
│   │   ├── 08/    (res://.git/objects/08)
│   │   │   └── ec3bd84342eaaf90b07ea69959473c5b83000f    (other)
│   │   ├── 0b/    (res://.git/objects/0b)
│   │   │   └── 0285cd52b808ee3c9445f282dada931497e6f9    (other)
│   │   ├── 0c/    (res://.git/objects/0c)
│   │   │   ├── 8360f4a10399bc4759b18c27165ac23eeb6034    (other)
│   │   │   └── 865570528bc5aa38fc68befe60ae65efb908b2    (other)
│   │   ├── 0d/    (res://.git/objects/0d)
│   │   │   └── ba4d3a3ec797a869a633d32619664c51138a7a    (other)
│   │   ├── 0e/    (res://.git/objects/0e)
│   │   │   └── 1cb91e6442eaef7b0ce7f04766723f6dffeac9    (other)
│   │   ├── 12/    (res://.git/objects/12)
│   │   │   └── 530b23a82eaef2e1cf884980af745079d29f47    (other)
│   │   ├── 13/    (res://.git/objects/13)
│   │   │   └── e6b5a4e9c47082daa76b2f1c95073c3192b005    (other)
│   │   ├── 1b/    (res://.git/objects/1b)
│   │   │   └── 585428f4bec6cbeaa23556599c16db57c385a7    (other)
│   │   ├── 1d/    (res://.git/objects/1d)
│   │   │   └── 29325fa6bf70071e811a1c22b481ed6d95800f    (other)
│   │   ├── 1e/    (res://.git/objects/1e)
│   │   │   ├── 21feca0b77e0979d8b1ce056757ae244393e92    (other)
│   │   │   ├── 3e9e5803c0dfe4d6d480b93415d9c1c5f9f7a5    (other)
│   │   │   └── 70d1f0d09e3b2badab58f696e0a404c2bb03a1    (other)
│   │   ├── 24/    (res://.git/objects/24)
│   │   │   └── 2ba3effceeb495f79815832869ae3766fd8b52    (other)
│   │   ├── 25/    (res://.git/objects/25)
│   │   │   └── 569c24dfc96a99cca4376511a2a8c506cfe1f2    (other)
│   │   ├── 26/    (res://.git/objects/26)
│   │   │   └── 7556e4fa0a0a380ddbf53612779ba87b3235b8    (other)
│   │   ├── 2a/    (res://.git/objects/2a)
│   │   │   └── 9a0d3acc04bdf2f5ecdbd899edb0fb3bc761f3    (other)
│   │   ├── 2c/    (res://.git/objects/2c)
│   │   │   └── 66b2138d01fed54c5bda907f1dac3f70b40511    (other)
│   │   ├── 2d/    (res://.git/objects/2d)
│   │   │   └── ac94551348c015ad502bf532fe0f20383c96d9    (other)
│   │   ├── 2e/    (res://.git/objects/2e)
│   │   │   ├── 88a3c8e428ab6746d174fd6c9ef221138217f9    (other)
│   │   │   └── 891d68cd99bd8eeb52a4556effb5354ec0076a    (other)
│   │   ├── 31/    (res://.git/objects/31)
│   │   │   └── 142cb61983394216e3d5656a806d568988f755    (other)
│   │   ├── 33/    (res://.git/objects/33)
│   │   │   └── df490ae743e85591c265c4aff8180c3bae6428    (other)
│   │   ├── 35/    (res://.git/objects/35)
│   │   │   └── 0aaf116508ea93649f7affe07aba84f4f99fb3    (other)
│   │   ├── 37/    (res://.git/objects/37)
│   │   │   └── 2c886ea28813b1a960736884690185f06df93e    (other)
│   │   ├── 3a/    (res://.git/objects/3a)
│   │   │   └── 307205619249762158e01ecf1c3f8332b8af2b    (other)
│   │   ├── 3f/    (res://.git/objects/3f)
│   │   │   └── d0d7e43b70a837e522ede32c117115da99a1cf    (other)
│   │   ├── 41/    (res://.git/objects/41)
│   │   │   ├── 0437b5e83f5d8967263286320f762e4b109b68    (other)
│   │   │   └── 10e36881fbe22f51224e35574a792fb6afed88    (other)
│   │   ├── 43/    (res://.git/objects/43)
│   │   │   ├── 762f89e4f8462e58e19cd549177a3d749b1601    (other)
│   │   │   ├── c47e1905d9491e374abfc16ce052f595592945    (other)
│   │   │   └── e4b33e46ec4ca1257bd8e104f6911b2d430d64    (other)
│   │   ├── 45/    (res://.git/objects/45)
│   │   │   └── 2fb74e935a266495ed49f85eaec60cf7d53579    (other)
│   │   ├── 47/    (res://.git/objects/47)
│   │   │   ├── 09183670ac629a32ff7df40816c79c7c932daa    (other)
│   │   │   └── 4aa678ee4de298d82549cb8796031eb4c248d3    (other)
│   │   ├── 48/    (res://.git/objects/48)
│   │   │   └── e9b8206412a78b0fa2ea5fb663c0c96c95d9d3    (other)
│   │   ├── 4b/    (res://.git/objects/4b)
│   │   │   └── 141308b6e316b478f3bfbafa54b0fbe48284b8    (other)
│   │   ├── 4c/    (res://.git/objects/4c)
│   │   │   └── 3a6ba111ca63f6e206a9644d051f2280814a45    (other)
│   │   ├── 50/    (res://.git/objects/50)
│   │   │   ├── 8c760b3e7bc47f867a2667a7f39285bd28e7fb    (other)
│   │   │   └── bb8664e61fe3abb383af746a2e3bae736d2adc    (other)
│   │   ├── 51/    (res://.git/objects/51)
│   │   │   └── 16ee5a7ffd1de9c6ecbcba429d0615226d5d20    (other)
│   │   ├── 52/    (res://.git/objects/52)
│   │   │   └── 33c3aa9a0b6d128e53f785a9dce426d742ba9f    (other)
│   │   ├── 54/    (res://.git/objects/54)
│   │   │   └── f47b34c242c6675839f672c350c1f895ede880    (other)
│   │   ├── 58/    (res://.git/objects/58)
│   │   │   ├── 1e0a079ccab7d5508ca1dff29688145ae8ad41    (other)
│   │   │   └── 3cdc20d11431a32b33dd8bfbac2bfa1533b042    (other)
│   │   ├── 59/    (res://.git/objects/59)
│   │   │   ├── 13b84ca9fe448f93e6f48f04b95644025e03ef    (other)
│   │   │   └── 8e56dece198d9286e515402ca088620d17ef4f    (other)
│   │   ├── 5d/    (res://.git/objects/5d)
│   │   │   ├── bf17a2ec34f84bb53bec7c9d63b7739fdf28ea    (other)
│   │   │   └── cb298d9d1dcea1fdbdd06117b6cc545b436657    (other)
│   │   ├── 5e/    (res://.git/objects/5e)
│   │   │   ├── 2ce52096e3847464659c70e93d48f35d3900c0    (other)
│   │   │   └── 6cd3721daac613d1c39c322899845c8fa2d30e    (other)
│   │   ├── 5f/    (res://.git/objects/5f)
│   │   │   └── 6cd889e1d1a9b7cb85290b0ffb75a37108d136    (other)
│   │   ├── 60/    (res://.git/objects/60)
│   │   │   └── 09cdd56c262a595d6b7330d40a1a4f95fe1249    (other)
│   │   ├── 61/    (res://.git/objects/61)
│   │   │   └── d7d5aad10cd5c4b89300a082d5193b67ac05c5    (other)
│   │   ├── 65/    (res://.git/objects/65)
│   │   │   └── 211c45cfa2bc3a784c9ed733a8b99d3f5997f9    (other)
│   │   ├── 66/    (res://.git/objects/66)
│   │   │   └── d6b2f0b21e939b1c0fe775e32fb453a2d6ffb1    (other)
│   │   ├── 6a/    (res://.git/objects/6a)
│   │   │   ├── 300c564a6db8574421e30dd3215eb3d9c00eca    (other)
│   │   │   ├── 64dba3e5a1983f684307a2b33253ab1d098051    (other)
│   │   │   ├── 7854a45a6ffb8d70503d671c0451dc403c04ec    (other)
│   │   │   └── 91cd4589ff465e678096e6b12a8021dd5539ce    (other)
│   │   ├── 6f/    (res://.git/objects/6f)
│   │   │   └── e60c8707c0c2d3966629075d79a8a258410b70    (other)
│   │   ├── 70/    (res://.git/objects/70)
│   │   │   └── 34f4a06869ac167b856500e3395a859cda5d29    (other)
│   │   ├── 76/    (res://.git/objects/76)
│   │   │   └── ca6f9d7daa1003150d31862b2ee135c350f9e9    (other)
│   │   ├── 78/    (res://.git/objects/78)
│   │   │   └── 2a4902827bf9bed2bc08bfc422a0d5064c03a2    (other)
│   │   ├── 79/    (res://.git/objects/79)
│   │   │   └── 6ad25bf1e5db591160859bbc4ddb43c141f40d    (other)
│   │   ├── 7c/    (res://.git/objects/7c)
│   │   │   └── 39b2476360dadcfc2277b37b271f280b9176bb    (other)
│   │   ├── 7e/    (res://.git/objects/7e)
│   │   │   └── abf11d5b9ae5a8ec8c20694f59beb8dff09c4a    (other)
│   │   ├── 7f/    (res://.git/objects/7f)
│   │   │   └── 5a0d350cb8e61cde5fd1ae36adcaef5ef47928    (other)
│   │   ├── 81/    (res://.git/objects/81)
│   │   │   └── eaac603f266757eb167e609ea1450f7fc65be6    (other)
│   │   ├── 82/    (res://.git/objects/82)
│   │   │   ├── 24d626cd304a6c1ac64bac3a202f927a156247    (other)
│   │   │   └── 4a2ad50a9e8c2a915aadca346d93ccc6951c92    (other)
│   │   ├── 85/    (res://.git/objects/85)
│   │   │   └── bece71ce4d3a97281998f64600156fc4c2c251    (other)
│   │   ├── 87/    (res://.git/objects/87)
│   │   │   └── e3d677a250e22ad8fd070b1dc313367f55cd70    (other)
│   │   ├── 88/    (res://.git/objects/88)
│   │   │   └── a4199e52cd35cbee3909c58136500765383fb7    (other)
│   │   ├── 89/    (res://.git/objects/89)
│   │   │   ├── 0dd72fe3c13f2b4b7cbd73b7a4b6496cc2893d    (other)
│   │   │   └── 398655951e137867343ea55137235f1a7f0c34    (other)
│   │   ├── 8a/    (res://.git/objects/8a)
│   │   │   └── d74f78d9c9b9b8f3d68772c6d5aa0cb3fe47e9    (other)
│   │   ├── 8b/    (res://.git/objects/8b)
│   │   │   ├── 137891791fe96927ad78e64b0aad7bded08bdc    (other)
│   │   │   └── ad51977be8e776046098167ec0a02368a73aa4    (other)
│   │   ├── 8e/    (res://.git/objects/8e)
│   │   │   ├── 755116a90cfa7c5c20fdd419aca915e7f463d7    (other)
│   │   │   └── c8703df007c9e8c603dec48aa14283cd77a5d4    (other)
│   │   ├── 90/    (res://.git/objects/90)
│   │   │   ├── 6acfa9b1aebb6bbd7b9fb914c46707af10e807    (other)
│   │   │   └── d9fe4b2d25e2b2b163f6f702729e58fa5c9c7e    (other)
│   │   ├── 91/    (res://.git/objects/91)
│   │   │   └── 92b72787a09ce3c94e8f86faaeedf6e28c0fe7    (other)
│   │   ├── 93/    (res://.git/objects/93)
│   │   │   └── 8c7c88fee329702c8009f7f3e19b7d4baf8455    (other)
│   │   ├── 94/    (res://.git/objects/94)
│   │   │   └── 196887a695ebe98fb45c4cbcde8c29cbe58442    (other)
│   │   ├── 95/    (res://.git/objects/95)
│   │   │   └── 653d44a91fdf3fb1dbd24539ae3cfd28718273    (other)
│   │   ├── 9a/    (res://.git/objects/9a)
│   │   │   └── 54c4617f878b0908a61a907e19de948727e7a1    (other)
│   │   ├── a0/    (res://.git/objects/a0)
│   │   │   └── 34408bf49d3688f7559ed4f89abd7e77dcfe45    (other)
│   │   ├── a6/    (res://.git/objects/a6)
│   │   │   └── b28260495a8b7c2dd869f09317954688ac3fd8    (other)
│   │   ├── a7/    (res://.git/objects/a7)
│   │   │   └── 2bbfbf7dace7de5b9832a65063e91ac8342442    (other)
│   │   ├── ab/    (res://.git/objects/ab)
│   │   │   └── f7dbcef6dd5d6b5d18a171e5e757850ffbcb25    (other)
│   │   ├── ac/    (res://.git/objects/ac)
│   │   │   ├── 4e587c2e3a739ca51dd88078e5b791fab916b1    (other)
│   │   │   ├── 9bf48f64ccfc96e82965bbaab349ce20d91b80    (other)
│   │   │   └── d46ed64e59cb01bdec577ad90042271085f66f    (other)
│   │   ├── ad/    (res://.git/objects/ad)
│   │   │   ├── c26df6c2cd666478b85216d4a6d93f61680cb7    (other)
│   │   │   └── eff3900a52f8b82802b682441137716b7f1ce8    (other)
│   │   ├── af/    (res://.git/objects/af)
│   │   │   ├── 35e5b6be6984d104a3cc5c7c5255439dec55f3    (other)
│   │   │   └── a8834283e3e42b98fc520b57d8050355a169bc    (other)
│   │   ├── b0/    (res://.git/objects/b0)
│   │   │   └── e24122ad06bd75d08c16dd20ae8c48615d44a9    (other)
│   │   ├── b1/    (res://.git/objects/b1)
│   │   │   └── 492b28f7f2083d85488edb33dba82778dcc2a4    (other)
│   │   ├── b2/    (res://.git/objects/b2)
│   │   │   └── 6cbc3440e1c7e07449410fa904c2d22a8e1669    (other)
│   │   ├── b3/    (res://.git/objects/b3)
│   │   │   └── c1f4438249dc26ef06eabdc4b0522ec262353f    (other)
│   │   ├── b7/    (res://.git/objects/b7)
│   │   │   └── a605ce20a2dc0457cfc20b0039e55539c57d32    (other)
│   │   ├── b8/    (res://.git/objects/b8)
│   │   │   └── e8234722f6961674d3f649137438e72219283d    (other)
│   │   ├── bb/    (res://.git/objects/bb)
│   │   │   ├── 27f55bddf8810837ab146e50919f15065fb665    (other)
│   │   │   └── 28482f01536d9570a36e2db77adb16f46bbbb8    (other)
│   │   ├── bf/    (res://.git/objects/bf)
│   │   │   └── c8c347d67ecf274be123c7370aaf55fa4e54a1    (other)
│   │   ├── c1/    (res://.git/objects/c1)
│   │   │   └── 6ae70058f6f6f1b5651a1c1e8c9723c1ebb832    (other)
│   │   ├── c6/    (res://.git/objects/c6)
│   │   │   ├── b96c477b38368496659e0718fd5a7fc569e6eb    (other)
│   │   │   └── df0a805b8887823cd656011e0d0f18cb71cad3    (other)
│   │   ├── c7/    (res://.git/objects/c7)
│   │   │   └── c67516555a8d0cc20709e238acc7047803fe54    (other)
│   │   ├── c9/    (res://.git/objects/c9)
│   │   │   └── 5ae0fe7bda6403bba01a4e63151942f3681aa3    (other)
│   │   ├── ce/    (res://.git/objects/ce)
│   │   │   └── 7fb508563d1210f0fc3a0c281ba18dd95d4a98    (other)
│   │   ├── d1/    (res://.git/objects/d1)
│   │   │   └── 2c1939c016eb07703b7de53d2f4319715c69ce    (other)
│   │   ├── d7/    (res://.git/objects/d7)
│   │   │   ├── 2d230b0f7c24099b45cca9e268a8334ad58daa    (other)
│   │   │   └── 550c128d0d7dae9279a42d1af6d4994d813a2f    (other)
│   │   ├── d8/    (res://.git/objects/d8)
│   │   │   └── 4052933e5e10801a2ffffede54a2279ff08674    (other)
│   │   ├── d9/    (res://.git/objects/d9)
│   │   │   └── c9e208d4e771492ddc39efe5ceaf9d2280416d    (other)
│   │   ├── db/    (res://.git/objects/db)
│   │   │   └── 98fea89f14f1a932443be5f89382e0d2312073    (other)
│   │   ├── dc/    (res://.git/objects/dc)
│   │   │   ├── 04c3f18ee106b7cabba11bf2fd4dc8baf86685    (other)
│   │   │   └── a8a49ccd85541d8e435e5206ef1313eef2b851    (other)
│   │   ├── de/    (res://.git/objects/de)
│   │   │   └── 7a5f8f0236ed64bf7ca7455c773d8ddec9a272    (other)
│   │   ├── e0/    (res://.git/objects/e0)
│   │   │   └── b6ac77388cc905273357765ff97d8738737d9e    (other)
│   │   ├── e4/    (res://.git/objects/e4)
│   │   │   ├── 18cc5842f663131fb342a2e4920532ac6d2754    (other)
│   │   │   └── 3733bc939550e09bd3c40f3fa5cf4234da23cf    (other)
│   │   ├── e6/    (res://.git/objects/e6)
│   │   │   └── 7766c6b1e4634d14e8e11fa8e72da06c8bd6ec    (other)
│   │   ├── e7/    (res://.git/objects/e7)
│   │   │   └── 6cba1e547f75f23605237ba497838defdc6097    (other)
│   │   ├── e8/    (res://.git/objects/e8)
│   │   │   └── efedff0d3f965b93d425f8ee42e4eb319a77b5    (other)
│   │   ├── ea/    (res://.git/objects/ea)
│   │   │   └── b187dcd2ef37dd3f8587723e2d858a49756d4e    (other)
│   │   ├── ec/    (res://.git/objects/ec)
│   │   │   └── a01c184c5281e5c0c186adae23c7c8b1e727c6    (other)
│   │   ├── ed/    (res://.git/objects/ed)
│   │   │   └── 48786e06054a0abe6073a25e6d0303292e508a    (other)
│   │   ├── ee/    (res://.git/objects/ee)
│   │   │   ├── 0933d152419b7356591165c44b2235e34cfd5a    (other)
│   │   │   └── 9ca5d3a9429bfe8c29e509e15cce7e96d3b879    (other)
│   │   ├── ef/    (res://.git/objects/ef)
│   │   │   └── 4aa704c393dd5c010570bf678d038474802aae    (other)
│   │   ├── f0/    (res://.git/objects/f0)
│   │   │   └── 7c7891e95ebe4d62a4d4ec7c8859ce6ac8f974    (other)
│   │   ├── f1/    (res://.git/objects/f1)
│   │   │   └── 9c6c2b892d296f3ea24fa0edc72b94a6059bf9    (other)
│   │   ├── f3/    (res://.git/objects/f3)
│   │   │   └── fb0c443af24cbad650c9e5970f3fab8ae7e646    (other)
│   │   ├── f4/    (res://.git/objects/f4)
│   │   │   ├── 820448359d340468a5abdd68f17336cfae1175    (other)
│   │   │   └── f1b1e3d133d8ee9d2fe0aad8c924591ecadba3    (other)
│   │   ├── f5/    (res://.git/objects/f5)
│   │   │   └── 8a262d1b95e9e37fd3cb80ba04b1b283db8c42    (other)
│   │   ├── f6/    (res://.git/objects/f6)
│   │   │   └── d59ddf5e997eacf82ebfe7bed46f7cb78bbb35    (other)
│   │   ├── f8/    (res://.git/objects/f8)
│   │   │   └── 5d3f85043752cd2eb1029f5e54b2b13fa1ac44    (other)
│   │   ├── f9/    (res://.git/objects/f9)
│   │   │   └── 1e9e0d38633e5409fbf64bea0888d7ca0e3645    (other)
│   │   ├── fb/    (res://.git/objects/fb)
│   │   │   ├── 8c0589f9f30853a7d992b0e56f06dacffdc20f    (other)
│   │   │   └── d1d01adfaeb56c74d81aebfbc02683d16c3802    (other)
│   │   ├── fc/    (res://.git/objects/fc)
│   │   │   └── b7491ce48a350126afbb566c10ceeb70353776    (other)
│   │   ├── fe/    (res://.git/objects/fe)
│   │   │   ├── 7dbed26d7feb4c9fef157c58c16da8ec273b1b    (other)
│   │   │   └── bb2c357d596d91c5db58ca93a22a7944fd8db2    (other)
│   │   ├── info/    (res://.git/objects/info)
│   │   └── pack/    (res://.git/objects/pack)
│   ├── refs/    (res://.git/refs)
│   │   ├── heads/    (res://.git/refs/heads)
│   │   │   ├── backup-before-refactor    (other)
│   │   │   └── master    (other)
│   │   └── tags/    (res://.git/refs/tags)
│   ├── worktrees/    (res://.git/worktrees)
│   │   ├── bqb/    (res://.git/worktrees/bqb)
│   │   │   ├── logs/    (res://.git/worktrees/bqb/logs)
│   │   │   │   └── HEAD    (other)
│   │   │   ├── refs/    (res://.git/worktrees/bqb/refs)
│   │   │   ├── commondir    (other)
│   │   │   ├── gitdir    (other)
│   │   │   ├── HEAD    (other)
│   │   │   ├── index    (other)
│   │   │   └── ORIG_HEAD    (other)
│   │   ├── eko/    (res://.git/worktrees/eko)
│   │   │   ├── logs/    (res://.git/worktrees/eko/logs)
│   │   │   │   └── HEAD    (other)
│   │   │   ├── refs/    (res://.git/worktrees/eko/refs)
│   │   │   ├── commondir    (other)
│   │   │   ├── gitdir    (other)
│   │   │   ├── HEAD    (other)
│   │   │   ├── index    (other)
│   │   │   └── ORIG_HEAD    (other)
│   │   ├── gbw/    (res://.git/worktrees/gbw)
│   │   │   ├── logs/    (res://.git/worktrees/gbw/logs)
│   │   │   │   └── HEAD    (other)
│   │   │   ├── refs/    (res://.git/worktrees/gbw/refs)
│   │   │   ├── commondir    (other)
│   │   │   ├── gitdir    (other)
│   │   │   ├── HEAD    (other)
│   │   │   ├── index    (other)
│   │   │   └── ORIG_HEAD    (other)
│   │   ├── gtb/    (res://.git/worktrees/gtb)
│   │   │   ├── logs/    (res://.git/worktrees/gtb/logs)
│   │   │   │   └── HEAD    (other)
│   │   │   ├── refs/    (res://.git/worktrees/gtb/refs)
│   │   │   ├── commondir    (other)
│   │   │   ├── gitdir    (other)
│   │   │   ├── HEAD    (other)
│   │   │   ├── index    (other)
│   │   │   └── ORIG_HEAD    (other)
│   │   ├── iaq/    (res://.git/worktrees/iaq)
│   │   │   ├── logs/    (res://.git/worktrees/iaq/logs)
│   │   │   │   └── HEAD    (other)
│   │   │   ├── refs/    (res://.git/worktrees/iaq/refs)
│   │   │   ├── commondir    (other)
│   │   │   ├── gitdir    (other)
│   │   │   ├── HEAD    (other)
│   │   │   ├── index    (other)
│   │   │   └── ORIG_HEAD    (other)
│   │   ├── jnx/    (res://.git/worktrees/jnx)
│   │   │   ├── logs/    (res://.git/worktrees/jnx/logs)
│   │   │   │   └── HEAD    (other)
│   │   │   ├── refs/    (res://.git/worktrees/jnx/refs)
│   │   │   ├── commondir    (other)
│   │   │   ├── gitdir    (other)
│   │   │   ├── HEAD    (other)
│   │   │   ├── index    (other)
│   │   │   └── ORIG_HEAD    (other)
│   │   ├── muz/    (res://.git/worktrees/muz)
│   │   │   ├── logs/    (res://.git/worktrees/muz/logs)
│   │   │   │   └── HEAD    (other)
│   │   │   ├── refs/    (res://.git/worktrees/muz/refs)
│   │   │   ├── commondir    (other)
│   │   │   ├── gitdir    (other)
│   │   │   ├── HEAD    (other)
│   │   │   ├── index    (other)
│   │   │   └── ORIG_HEAD    (other)
│   │   ├── osn/    (res://.git/worktrees/osn)
│   │   │   ├── logs/    (res://.git/worktrees/osn/logs)
│   │   │   │   └── HEAD    (other)
│   │   │   ├── refs/    (res://.git/worktrees/osn/refs)
│   │   │   ├── commondir    (other)
│   │   │   ├── gitdir    (other)
│   │   │   ├── HEAD    (other)
│   │   │   ├── index    (other)
│   │   │   └── ORIG_HEAD    (other)
│   │   ├── pmg/    (res://.git/worktrees/pmg)
│   │   │   ├── logs/    (res://.git/worktrees/pmg/logs)
│   │   │   │   └── HEAD    (other)
│   │   │   ├── refs/    (res://.git/worktrees/pmg/refs)
│   │   │   ├── commondir    (other)
│   │   │   ├── gitdir    (other)
│   │   │   ├── HEAD    (other)
│   │   │   ├── index    (other)
│   │   │   └── ORIG_HEAD    (other)
│   │   ├── qlt/    (res://.git/worktrees/qlt)
│   │   │   ├── logs/    (res://.git/worktrees/qlt/logs)
│   │   │   │   └── HEAD    (other)
│   │   │   ├── refs/    (res://.git/worktrees/qlt/refs)
│   │   │   ├── commondir    (other)
│   │   │   ├── gitdir    (other)
│   │   │   ├── HEAD    (other)
│   │   │   ├── index    (other)
│   │   │   └── ORIG_HEAD    (other)
│   │   ├── qwa/    (res://.git/worktrees/qwa)
│   │   │   ├── logs/    (res://.git/worktrees/qwa/logs)
│   │   │   │   └── HEAD    (other)
│   │   │   ├── refs/    (res://.git/worktrees/qwa/refs)
│   │   │   ├── commondir    (other)
│   │   │   ├── gitdir    (other)
│   │   │   ├── HEAD    (other)
│   │   │   ├── index    (other)
│   │   │   └── ORIG_HEAD    (other)
│   │   ├── upq/    (res://.git/worktrees/upq)
│   │   │   ├── logs/    (res://.git/worktrees/upq/logs)
│   │   │   │   └── HEAD    (other)
│   │   │   ├── refs/    (res://.git/worktrees/upq/refs)
│   │   │   ├── commondir    (other)
│   │   │   ├── gitdir    (other)
│   │   │   ├── HEAD    (other)
│   │   │   ├── index    (other)
│   │   │   └── ORIG_HEAD    (other)
│   │   ├── vdk/    (res://.git/worktrees/vdk)
│   │   │   ├── logs/    (res://.git/worktrees/vdk/logs)
│   │   │   │   └── HEAD    (other)
│   │   │   ├── refs/    (res://.git/worktrees/vdk/refs)
│   │   │   ├── commondir    (other)
│   │   │   ├── gitdir    (other)
│   │   │   ├── HEAD    (other)
│   │   │   ├── index    (other)
│   │   │   ├── index.lock    (other)
│   │   │   ├── locked    (other)
│   │   │   └── ORIG_HEAD    (other)
│   │   ├── wfi/    (res://.git/worktrees/wfi)
│   │   │   ├── logs/    (res://.git/worktrees/wfi/logs)
│   │   │   │   └── HEAD    (other)
│   │   │   ├── refs/    (res://.git/worktrees/wfi/refs)
│   │   │   ├── commondir    (other)
│   │   │   ├── gitdir    (other)
│   │   │   ├── HEAD    (other)
│   │   │   ├── index    (other)
│   │   │   └── ORIG_HEAD    (other)
│   │   ├── xpz/    (res://.git/worktrees/xpz)
│   │   │   ├── logs/    (res://.git/worktrees/xpz/logs)
│   │   │   │   └── HEAD    (other)
│   │   │   ├── refs/    (res://.git/worktrees/xpz/refs)
│   │   │   ├── commondir    (other)
│   │   │   ├── gitdir    (other)
│   │   │   ├── HEAD    (other)
│   │   │   ├── index    (other)
│   │   │   └── ORIG_HEAD    (other)
│   │   └── xuy/    (res://.git/worktrees/xuy)
│   │       ├── logs/    (res://.git/worktrees/xuy/logs)
│   │       │   └── HEAD    (other)
│   │       ├── refs/    (res://.git/worktrees/xuy/refs)
│   │       ├── commondir    (other)
│   │       ├── gitdir    (other)
│   │       ├── HEAD    (other)
│   │       ├── index    (other)
│   │       └── ORIG_HEAD    (other)
│   ├── COMMIT_EDITMSG    (other)
│   ├── config    (other)
│   ├── description    (other)
│   ├── HEAD    (other)
│   ├── index    (other)
│   ├── ORIG_HEAD    (other)
│   ├── README 2.txt    (other)
│   └── README.txt    (other)
├── android/    (res://android)
│   ├── build/    (res://android/build)
│   │   ├── templates/    (res://android/build/templates)
│   │   │   ├── android_debug.apk    (other)
│   │   │   ├── android_release.apk    (other)
│   │   │   ├── android_source.zip    (other)
│   │   │   ├── icudt_godot.dat    (other)
│   │   │   ├── ios.zip    (other)
│   │   │   ├── linux_debug.arm32    (other)
│   │   │   ├── linux_debug.arm64    (other)
│   │   │   ├── linux_debug.x86_32    (other)
│   │   │   ├── linux_debug.x86_64    (other)
│   │   │   ├── linux_release.arm32    (other)
│   │   │   ├── linux_release.arm64    (other)
│   │   │   ├── linux_release.x86_32    (other)
│   │   │   ├── linux_release.x86_64    (other)
│   │   │   ├── macos.zip    (other)
│   │   │   ├── version.txt    (other)
│   │   │   ├── visionos.zip    (other)
│   │   │   ├── web_debug.zip    (other)
│   │   │   ├── web_dlink_debug.zip    (other)
│   │   │   ├── web_dlink_nothreads_debug.zip    (other)
│   │   │   ├── web_dlink_nothreads_release.zip    (other)
│   │   │   ├── web_dlink_release.zip    (other)
│   │   │   ├── web_nothreads_debug.zip    (other)
│   │   │   ├── web_nothreads_release.zip    (other)
│   │   │   ├── web_release.zip    (other)
│   │   │   ├── windows_debug_arm64.exe    (other)
│   │   │   ├── windows_debug_arm64_console.exe    (other)
│   │   │   ├── windows_debug_x86_32.exe    (other)
│   │   │   ├── windows_debug_x86_32_console.exe    (other)
│   │   │   ├── windows_debug_x86_64.exe    (other)
│   │   │   ├── windows_debug_x86_64_console.exe    (other)
│   │   │   ├── windows_release_arm64.exe    (other)
│   │   │   ├── windows_release_arm64_console.exe    (other)
│   │   │   ├── windows_release_x86_32.exe    (other)
│   │   │   ├── windows_release_x86_32_console.exe    (other)
│   │   │   ├── windows_release_x86_64.exe    (other)
│   │   │   └── windows_release_x86_64_console.exe    (other)
│   │   └── .gdignore    (other)
│   └── .build_version    (other)
├── heroes/    (res://heroes)
│   ├── hero_blue.png    (other)
│   ├── hero_blue.png.import    (other)
│   ├── hero_blue_frames.png    (other)
│   ├── hero_blue_frames.png.import    (other)
│   ├── hero_blue_jump_frames.tres    (other)
│   ├── hero_default.png    (other)
│   ├── hero_default.png.import    (other)
│   ├── hero_default_frames.png    (other)
│   ├── hero_default_frames.png.import    (other)
│   ├── hero_default_jump_frames.tres    (other)
│   ├── hero_monster.png    (other)
│   ├── hero_monster.png.import    (other)
│   ├── hero_monster_frames.png    (other)
│   ├── hero_monster_frames.png.import    (other)
│   ├── hero_monster_jump_frames.tres    (other)
│   ├── hero_orange.png    (other)
│   ├── hero_orange.png.import    (other)
│   ├── hero_orange_frames.png    (other)
│   ├── hero_orange_frames.png.import    (other)
│   ├── hero_orange_jump_frames.tres    (other)
│   ├── hero_red.png    (other)
│   ├── hero_red.png.import    (other)
│   ├── hero_red_frames.png    (other)
│   ├── hero_red_frames.png.import    (other)
│   └── hero_red_jump_frames.tres    (other)
├── scripts/    (res://scripts)
│   ├── Level.gd    (gd)
│   ├── Level.gd.uid    (other)
│   ├── Platform.gd    (gd)
│   ├── Platform.gd.uid    (other)
│   ├── Player.gd    (gd)
│   └── Player.gd.uid    (other)
├── wall/    (res://wall)
│   ├── data/    (res://wall/data)
│   │   ├── WallData.gd    (gd)
│   │   └── WallData.gd.uid    (other)
│   ├── segment/    (res://wall/segment)
│   │   ├── WallSegment.gd    (gd)
│   │   ├── WallSegment.gd.uid    (other)
│   │   └── WallSegment.tscn    (tscn)
│   │       ├── WallSegment (Node2D)
│   │       ├── Sprite2D (Sprite2D)
│   │       ├── Area2D (Area2D)
│   │       └── VisibleOnScreenNotifier2D (VisibleOnScreenNotifier2D)
│   ├── textures/    (res://wall/textures)
│   │   ├── wall_segment.png    (other)
│   │   └── wall_segment.png.import    (other)
│   ├── wall.gd    (gd)
│   ├── wall.gd.uid    (other)
│   ├── wall.tscn    (tscn)
│   ├── WallRenderer.gd    (gd)
│   ├── WallRenderer.gd.uid    (other)
│   ├── WallView.gd    (gd)
│   └── WallView.gd.uid    (other)
├── .gitignore    (other)
├── all_files_list.txt    (other)
├── ARCHITECTURE_NOTES.md    (other)
├── Champions.gd    (gd)
├── Champions.gd.uid    (other)
├── Champions.tscn    (tscn)
│   ├── Champions (Control)
│   └── CenterContainer (CenterContainer)
├── Coin.gd    (gd)
├── Coin.gd.uid    (other)
├── Coin.tscn    (tscn)
│   ├── Coin (Area2D)
│   └── CollisionShape2D (CollisionShape2D)
├── CubeView.gd    (gd)
├── CubeView.gd.uid    (other)
├── CubeView.tscn    (tscn)
│   ├── CubeView (Node2D)
│   ├── Camera2D (Camera2D)
│   ├── GateLine (Line2D)
│   └── UILayer (CanvasLayer)
├── export_presets.cfg    (other)
├── GameOver.gd    (gd)
├── GameOver.gd.uid    (other)
├── GameOver.tscn    (tscn)
│   ├── GameOver (CanvasLayer)
│   ├── GameOver#MobileScale (Node)
│   └── Panel (Panel)
├── GameState.gd    (gd)
├── GameState.gd.uid    (other)
├── HUD.gd    (gd)
├── HUD.gd.uid    (other)
├── icon.svg    (other)
├── icon.svg.import    (other)
├── level.tscn    (tscn)
│   ├── Level (Node2D)
│   ├── Platforms (Node2D)
│   ├── Player (CharacterBody2D)
│   │   ├── Camera2D (Camera2D)
│   │   ├── CollisionShape2D (CollisionShape2D)
│   │   ├── AnimatedSprite2D (AnimatedSprite2D)
│   │   └── CustomAvatarSprite (Sprite2D)
│   └── HUDLayer (CanvasLayer)
├── LoadingLevel.tscn    (tscn)
│   ├── LoadingLevel (Control)
│   └── CenterContainer (CenterContainer)
├── MainMenu.gd    (gd)
├── MainMenu.gd.uid    (other)
├── MainMenu.tscn    (tscn)
│   ├── MainMenu (Control)
│   ├── RootHBox (HBoxContainer)
│   │   ├── LeftPanel (Panel)
│   │   │   ├── NicknameLabel (Label)
│   │   │   └── VBoxButtons (VBoxContainer)
│   │   │       ├── TitleLabel (Label)
│   │   │       ├── PlayButton (Button)
│   │   │       ├── ChampionsButton (Button)
│   │   │       ├── ProfileButton (Button)
│   │   │       └── CubeViewButton (Button)
│   │   └── RightPanel (CenterContainer)
│   └── WarnDialog (AcceptDialog)
├── MobileUIScale.gd    (gd)
├── MobileUIScale.gd.uid    (other)
├── Platform.tscn    (tscn)
│   ├── Platform (StaticBody2D)
│   └── CollisionShape2D (CollisionShape2D)
├── Profile.gd    (gd)
├── Profile.gd.uid    (other)
├── Profile.tscn    (tscn)
│   ├── Profile (Control)
│   ├── CenterContainer (CenterContainer)
│   ├── FileDialogJumpUp (FileDialog)
│   ├── FileDialogJumpDown (FileDialog)
│   └── WarnDialog (AcceptDialog)
├── project.godot    (other)
├── project_dump_errors.log    (other)
├── README.txt    (other)
└── концептуально-архитектурное ТЗ.txt    (other)

=== SCENE TREES (ASCII) ===


--- SCENE: res://Champions.tscn ---

├── Champions (Control)
└── CenterContainer (CenterContainer)

--- SCENE: res://Coin.tscn ---

├── Coin (Area2D)
└── CollisionShape2D (CollisionShape2D)

--- SCENE: res://CubeView.tscn ---

├── CubeView (Node2D)
├── Camera2D (Camera2D)
├── GateLine (Line2D)
└── UILayer (CanvasLayer)

--- SCENE: res://GameOver.tscn ---

├── GameOver (CanvasLayer)
├── GameOver#MobileScale (Node)
└── Panel (Panel)

--- SCENE: res://level.tscn ---

├── Level (Node2D)
├── Platforms (Node2D)
├── Player (CharacterBody2D)
│   ├── Camera2D (Camera2D)
│   ├── CollisionShape2D (CollisionShape2D)
│   ├── AnimatedSprite2D (AnimatedSprite2D)
│   └── CustomAvatarSprite (Sprite2D)
└── HUDLayer (CanvasLayer)

--- SCENE: res://LoadingLevel.tscn ---

├── LoadingLevel (Control)
└── CenterContainer (CenterContainer)

--- SCENE: res://MainMenu.tscn ---

├── MainMenu (Control)
├── RootHBox (HBoxContainer)
│   ├── LeftPanel (Panel)
│   │   ├── NicknameLabel (Label)
│   │   └── VBoxButtons (VBoxContainer)
│   │       ├── TitleLabel (Label)
│   │       ├── PlayButton (Button)
│   │       ├── ChampionsButton (Button)
│   │       ├── ProfileButton (Button)
│   │       └── CubeViewButton (Button)
│   └── RightPanel (CenterContainer)
└── WarnDialog (AcceptDialog)

--- SCENE: res://Platform.tscn ---

├── Platform (StaticBody2D)
└── CollisionShape2D (CollisionShape2D)

--- SCENE: res://Profile.tscn ---

├── Profile (Control)
├── CenterContainer (CenterContainer)
├── FileDialogJumpUp (FileDialog)
├── FileDialogJumpDown (FileDialog)
└── WarnDialog (AcceptDialog)

--- SCENE: res://wall/segment/WallSegment.tscn ---

├── WallSegment (Node2D)
├── Sprite2D (Sprite2D)
├── Area2D (Area2D)
└── VisibleOnScreenNotifier2D (VisibleOnScreenNotifier2D)

--- SCENE: res://wall/wall.tscn ---


=== SELF-VALIDATION: SCENE STRUCTURE VERIFICATION ===

res://Champions.tscn : 8 node(s) total
  - Champions (Control)
  - CenterContainer (CenterContainer)
    - Panel (Panel)
      - VBoxContainer (VBoxContainer)
        - TitleLabel (Label)
        - ScrollContainer (ScrollContainer)
          - List (VBoxContainer)
        - BackButton (Button)
res://Coin.tscn : 2 node(s) total
  - Coin (Area2D)
  - CollisionShape2D (CollisionShape2D)
res://CubeView.tscn : 8 node(s) total
  - CubeView (Node2D)
  - Camera2D (Camera2D)
  - GateLine (Line2D)
  - UILayer (CanvasLayer)
    - Panel (Panel)
      - VBoxContainer (VBoxContainer)
        - TitleLabel (Label)
        - BackButton (Button)
res://GameOver.tscn : 11 node(s) total
  - GameOver (CanvasLayer)
  - GameOver#MobileScale (Node)
  - Panel (Panel)
    - VBox (VBoxContainer)
      - TitleLabel (Label)
      - HeightLabel (Label)
      - ScoreLabel (Label)
      - Buttons (HBoxContainer)
        - ViewCubeButton (Button)
        - RestartButton (Button)
        - MainMenuButton (Button)
res://level.tscn : 13 node(s) total
  - Level (Node2D)
  - Platforms (Node2D)
  - Player (CharacterBody2D)
    - Camera2D (Camera2D)
    - CollisionShape2D (CollisionShape2D)
    - AnimatedSprite2D (AnimatedSprite2D)
    - CustomAvatarSprite (Sprite2D)
  - HUDLayer (CanvasLayer)
    - HUD (Control)
      - VBoxContainer (VBoxContainer)
        - NameLabel (Label)
        - ScoreLabel (Label)
      - BackButton (Button)
res://LoadingLevel.tscn : 3 node(s) total
  - LoadingLevel (Control)
  - CenterContainer (CenterContainer)
    - Label (Label)
res://MainMenu.tscn : 13 node(s) total
  - MainMenu (Control)
  - RootHBox (HBoxContainer)
    - LeftPanel (Panel)
      - NicknameLabel (Label)
      - VBoxButtons (VBoxContainer)
        - TitleLabel (Label)
        - PlayButton (Button)
        - ChampionsButton (Button)
        - ProfileButton (Button)
        - CubeViewButton (Button)
    - RightPanel (CenterContainer)
      - AvatarPreview (TextureRect)
  - WarnDialog (AcceptDialog)
res://Platform.tscn : 2 node(s) total
  - Platform (StaticBody2D)
  - CollisionShape2D (CollisionShape2D)
res://Profile.tscn : 22 node(s) total
  - Profile (Control)
  - CenterContainer (CenterContainer)
    - Panel (Panel)
      - VBoxContainer (VBoxContainer)
        - TitleLabel (Label)
        - NicknameEdit (LineEdit)
        - HeroSelector (HBoxContainer)
          - HeroLeftButton (Button)
          - HeroPreview (TextureRect)
          - HeroRightButton (Button)
          - HeroNameLabel (Label)
        - CustomAvatarRow (VBoxContainer)
          - CustomAvatarCheck (CheckBox)
          - UploadJumpUpButton (Button)
          - UploadJumpDownButton (Button)
        - WallBreathingCheck (CheckBox)
        - ButtonsRow (HBoxContainer)
          - SaveButton (Button)
          - BackButton (Button)
  - FileDialogJumpUp (FileDialog)
  - FileDialogJumpDown (FileDialog)
  - WarnDialog (AcceptDialog)
res://wall/segment/WallSegment.tscn : 5 node(s) total
  - WallSegment (Node2D)
  - Sprite2D (Sprite2D)
  - Area2D (Area2D)
    - CollisionShape2D (CollisionShape2D)
  - VisibleOnScreenNotifier2D (VisibleOnScreenNotifier2D)
res://wall/wall.tscn : 1 node(s) total
  - Wall (Node2D)

--- VALIDATION ISSUES ---
INFO: res://wall/wall.tscn has only 1 node (might be correct for simple scenes)

=== FILES (.gd and .tscn) ===


--- FILE: D:\YandexDisk\Projects\Runner\Godot\Champions.gd ---

extends Control
# ============================================================================
# Champions.gd — отдельная сцена таблицы чемпионов
# ----------------------------------------------------------------------------
# Требования:
# - отдельный экран
# - корректная сортировка (GameState уже сортирует по score desc)
# - кнопка Back возвращает в MainMenu
# ============================================================================

@export_file("*.tscn")
var main_menu_scene: String = "res://MainMenu.tscn"

@onready var list_box: VBoxContainer = $CenterContainer/Panel/VBoxContainer/ScrollContainer/List
@onready var back_button: Button = $CenterContainer/Panel/VBoxContainer/BackButton
@onready var title_label: Label = $CenterContainer/Panel/VBoxContainer/TitleLabel

func _ready() -> void:
	if title_label:
		title_label.text = "Champions"

	if back_button and not back_button.pressed.is_connected(_on_back_pressed):
		back_button.pressed.connect(_on_back_pressed)

	_refresh()

func _refresh() -> void:
	if list_box == null:
		return

	for c in list_box.get_children():
		c.queue_free()

	var champs: Array = GameState.get_champions()
	if champs.is_empty():
		var lbl := Label.new()
		lbl.text = "Пока пусто"
		lbl.horizontal_alignment = HORIZONTAL_ALIGNMENT_LEFT
		list_box.add_child(lbl)
		return

	for i in range(champs.size()):
		var e = champs[i]
		var place := i + 1
		var n := "???"
		var s := 0
		if typeof(e) == TYPE_DICTIONARY:
			n = str(e.get("name", "???"))
			s = int(e.get("score", 0))

		var lbl2 := Label.new()
		lbl2.text = str(place) + ". " + n + " — " + str(s)
		lbl2.horizontal_alignment = HORIZONTAL_ALIGNMENT_LEFT
		list_box.add_child(lbl2)

func _on_back_pressed() -> void:
	var err := get_tree().change_scene_to_file(main_menu_scene)
	if err != OK:
		push_error("Champions.gd: не удалось вернуться в меню: " + main_menu_scene)


--- FILE: D:\YandexDisk\Projects\Runner\Godot\Champions.tscn ---

[gd_scene load_steps=2 format=3 uid="uid://pnkpfmiog8kr"]

[ext_resource type="Script" uid="uid://x4f0dpsn3ien" path="res://Champions.gd" id="1_champions"]

[node name="Champions" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_champions")

[node name="CenterContainer" type="CenterContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="Panel" type="Panel" parent="CenterContainer"]
custom_minimum_size = Vector2(800, 520)
layout_mode = 2

[node name="VBoxContainer" type="VBoxContainer" parent="CenterContainer/Panel"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 24.0
offset_top = 24.0
offset_right = -24.0
offset_bottom = -24.0
grow_horizontal = 2
grow_vertical = 2

[node name="TitleLabel" type="Label" parent="CenterContainer/Panel/VBoxContainer"]
layout_mode = 2
theme_override_font_sizes/font_size = 32
text = "Champions"

[node name="ScrollContainer" type="ScrollContainer" parent="CenterContainer/Panel/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 3

[node name="List" type="VBoxContainer" parent="CenterContainer/Panel/VBoxContainer/ScrollContainer"]
layout_mode = 2
size_flags_vertical = 3

[node name="BackButton" type="Button" parent="CenterContainer/Panel/VBoxContainer"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
text = "Back"


--- FILE: D:\YandexDisk\Projects\Runner\Godot\Coin.gd ---

extends Area2D
# Coin.gd - ИСПРАВЛЕННАЯ ВЕРСИЯ

@export var value: int = 1
@export var radius: float = 16.0

@onready var collision: CollisionShape2D = $CollisionShape2D

func _ready() -> void:
	# Монета на переднем плане (z_index > стены)
	z_index = 1
	
	# ВАЖНО: Включаем мониторинг
	monitoring = true
	monitorable = true
	
	# КРИТИЧЕСКИ ВАЖНО: СЛОИ КОЛЛИЗИИ
	# Монета на слое 2, реагирует на маску 1 (игрок)
	set_collision_layer_value(2, true)
	set_collision_mask_value(1, true)
	
	# ВЫКЛЮЧАЕМ все остальные слои
	for i in range(1, 33):
		if i != 2:
			set_collision_layer_value(i, false)
		if i != 1:
			set_collision_mask_value(i, false)

	# СОЗДАЕМ КОЛЛАЙДЕР (круг)
	if collision != null:
		var shape = CircleShape2D.new()
		shape.radius = radius
		collision.shape = shape

	# ПОДКЛЮЧАЕМ СИГНАЛ
	if not body_entered.is_connected(_on_body_entered):
		body_entered.connect(_on_body_entered)
		
	
	queue_redraw()

func _on_body_entered(body: Node) -> void:
	
	if body is CharacterBody2D and body.name == "Player":
		
		
		# Добавляем очки
		GameState.add_coin(value)
		
		# Исчезаем
		queue_free()

func _draw() -> void:
	# РИСУЕМ КРАСИВУЮ МОНЕТУ
	var center = Vector2.ZERO
	
	# Жёлтая середина
	draw_circle(center, radius, Color(1.0, 0.84, 0.0, 1.0))
	
	# Тёмно-жёлтый ободок
	draw_arc(center, radius, 0, TAU, 32, Color(0.8, 0.6, 0.0, 1.0), 3.0)
	
	# Внутренний круг
	draw_circle(center, radius * 0.6, Color(1.0, 0.9, 0.3, 1.0))
	
	# Блик
	draw_circle(Vector2(-radius * 0.3, -radius * 0.3), radius * 0.2, Color(1.0, 1.0, 1.0, 0.8))


--- FILE: D:\YandexDisk\Projects\Runner\Godot\Coin.tscn ---

[gd_scene load_steps=2 format=3 uid="uid://caso0eomqoq3b"]

[ext_resource type="Script" path="res://Coin.gd" id="1_7hm3t"]

[node name="Coin" type="Area2D"]
script = ExtResource("1_7hm3t")

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]


--- FILE: D:\YandexDisk\Projects\Runner\Godot\CubeView.gd ---

extends Node2D
# ============================================================================
# CubeView.gd
# ============================================================================
# СЦЕНА ПРОСМОТРА СТЕНЫ ВНЕ ИГРОВОГО ПРОЦЕССА
# ----------------------------------------------------------------------------
# ЗАДАЧА:
# - Показать ту же самую сцену стены, что используется в игровом уровне.
# - Не переписывать и не дублировать логику стены/сегментов.
# - Повторно использовать wall.tscn и WallSegment.gd «как есть».
# - Добавить высотный гейт (горизонтальная линия), ниже которого сегменты
#   кликабельны, а выше — клики игнорируются.
# - Обеспечить архитектуру для будущей покупки сегментов в CubeView.
# ----------------------------------------------------------------------------
# ВАЖНЫЙ КОНСТРАИНТ:
# - Рандомные повороты, дыхание и прочая «жизнь» сегментов реализованы
#   внутри WallSegment.gd и уже работают. Здесь мы НИЧЕГО в них не трогаем.
# - CubeView отвечает только за:
#   * инстанс стены
#   * установку высотного гейта
#   * ограничение кликов по сегментам выше гейта
#   * простейший UI-навигации
# ============================================================================

## Путь к сцене стены.
## ВАЖНО: это та же сцена, которая используется в игровом уровне.
@export_file("*.tscn")
var wall_scene_path: String = "res://wall/wall.tscn"

## Ссылка на инстанс сцены стены (создаётся в _ready).
var wall_instance: Node2D = null

## Нода визуальной линии-гейта (Line2D или любой другой Node2D).
## Типизировано как Node2D, потому что нас интересует только её position.y.
@onready var gate_line: Node2D = $GateLine

## UI-слой для кнопок навигации / подписей.
@onready var ui_layer: CanvasLayer = $UILayer
@onready var back_button: Button = $UILayer/Panel/VBoxContainer/BackButton

## Высота-гейт по Y в мировых координатах CubeView.
## Сегменты с global_position.y > gate_y считаются НИЖЕ линии (доступны),
## а с y <= gate_y — ВЫШЕ линии (клики игнорируются).
var gate_y: float = 0.0

## Флаг разрешения покупок (включается в _ready)
var allow_purchases: bool = true


func _ready() -> void:
	# ------------------------------------------------------------
	# 1. Инстанс существующей сцены стены.
	# ------------------------------------------------------------
	# Загружаем wall.tscn и включаем покупки (allow_purchases = true)
	# ------------------------------------------------------------
	if wall_scene_path == "":
		push_error("CubeView.gd: wall_scene_path is empty")
	else:
		# Тип res указываем явно как Resource, затем кастуем к PackedScene.
		# Это безопасно, т.к. мы знаем, что wall_scene_path указывает на .tscn.
		var res: Resource = load(wall_scene_path)
		var packed: PackedScene = res as PackedScene
		if packed != null:
			var inst: Node = packed.instantiate()
			# Дополнительно убеждаемся, что это именно Node2D.
			wall_instance = inst as Node2D
			if wall_instance != null:
				add_child(wall_instance)
				# Для наглядности центрируем стену около (0,0) CubeView.
				wall_instance.position = Vector2.ZERO
				
				# ВКЛЮЧАЕМ покупки для CubeView
				wall_instance.allow_purchases = true
				# Также обновляем рендерер если он уже создан
				call_deferred("_enable_purchases_in_renderer")
		else:
			push_error("CubeView.gd: cannot load wall scene as PackedScene: " + wall_scene_path)

	# ------------------------------------------------------------
	# 2. Настройка UI-навигации.
	# ------------------------------------------------------------
	# UI здесь минимальный:
	# - BackButton возвращает игрока в главное меню.
	# - В будущем сюда можно добавить:
	#   * информацию о высоте
	#   * баланс монет
	#   * кнопки фильтров / сортировки сегментов
	# ------------------------------------------------------------
	if back_button != null and not back_button.pressed.is_connected(_on_back_button_pressed):
		back_button.pressed.connect(_on_back_button_pressed)

	# ------------------------------------------------------------
	# 3. Вычисляем высоту-гейт на основе GameState.
	# ------------------------------------------------------------
	# Архитектурно здесь предполагается, что:
	# - GameState хранит максимальную достигнутую высоту игрока в world-space.
	# - Для упрощения считаем, что ось Y такая же, как в Level:
	#   * чем МЕНЬШЕ y, тем ВЫШЕ игрок находится.
	#   * max_height_reached / max_height_reached (у нас max_height_reached) —
	#     минимальное значение y, которого достигал игрок (самая верхняя точка).
	# В этом коде мы читаем поле GameState.max_height_reached через get().
	# Если оно пока не задано или не является числом, просто ставим гейт
	# немного выше центра (условное значение -200).
	# ------------------------------------------------------------
	var has_gs: bool = Engine.has_singleton("GameState")
	if has_gs and GameState.has_method("get"):
		# Тип v объявлен как Variant, т.к. метод get() может вернуть что угодно.
		var v: Variant = GameState.get("max_height_reached")
		if v is float or v is int:
			gate_y = float(v)
		else:
			gate_y = -200.0
	else:
		gate_y = -200.0

	# В этом прототипе мы НИКАК не модифицируем GameState;
	# предполагается, что игровая сцена уже обновляет max_height_reached.

	# ------------------------------------------------------------
	# 4. Размещаем визуальную линию-гейт.
	# ------------------------------------------------------------
	# Мы считаем, что GateLine — это Line2D под корнем CubeView
	# с точками, заданными относительно её локальной позиции:
	#   ( -10000, 0 ) .. ( 10000, 0 )
	# Тогда её global Y = position.y. Мы просто ставим её на gate_y.
	# ------------------------------------------------------------
	if gate_line != null:
		gate_line.position.y = gate_y

	# ------------------------------------------------------------
	# 5. Подключаем обработку кликов для покупки сегментов.
	# ------------------------------------------------------------
	# Теперь клики обрабатываются через handle_click() в wall.gd,
	# который использует координаты вместо Area2D на каждый сегмент.
	# Высотный гейт проверяется внутри handle_click()
	# ------------------------------------------------------------
	_enable_purchases_in_renderer()

func _enable_purchases_in_renderer() -> void:
	if wall_instance == null:
		return
	wall_instance.allow_purchases = true
	# Ищем рендерер среди всех детей (может быть создан позже)
	for child in wall_instance.get_children():
		if child is WallRenderer:
			child.allow_purchases = true


func _input(event: InputEvent) -> void:
	# Обработка кликов для покупки сегментов
	if not allow_purchases:
		return
	
	if event is InputEventMouseButton and event.pressed and event.button_index == MOUSE_BUTTON_LEFT:
		if wall_instance == null:
			return
		
		# Получаем данные сегмента по координатам клика
		var click_data: Dictionary = wall_instance.handle_click(event.global_position)
		if click_data.is_empty():
			return
		
		# Проверяем высотный гейт (в Godot Y меньше = выше)
		var seg_height: float = float(click_data.get("height", 0.0))
		if seg_height < gate_y:
			return  # Сегмент выше достигнутой высоты
		
		# Покупаем сегмент
		_try_purchase_segment(click_data)
	
	elif event is InputEventScreenTouch and event.pressed:
		if wall_instance == null:
			return
		
		# Обработка тача на мобильных устройствах
		# Преобразуем экранные координаты в мировые
		var viewport: Viewport = get_viewport()
		var global_touch_pos: Vector2 = viewport.get_global_mouse_position()
		var click_data: Dictionary = wall_instance.handle_click(global_touch_pos)
		if click_data.is_empty():
			return
		
		var seg_height: float = float(click_data.get("height", 0.0))
		if seg_height < gate_y:
			return
		
		_try_purchase_segment(click_data)

func _try_purchase_segment(click_data: Dictionary) -> void:
	var segment_id: String = str(click_data.get("segment_id", ""))
	var side: String = str(click_data.get("side", "front"))
	var price: int = int(click_data.get("price", 0))
	
	if segment_id == "" or wall_instance == null:
		return
	
	# Получаем wall_data из wall_instance
	var wall_data: WallData = null
	if wall_instance.has_node("WallData"):
		wall_data = wall_instance.get_node("WallData") as WallData
	
	if wall_data == null:
		return
	
	# Покупаем сторону сегмента
	var buyer_uid: String = GameState.player_uid if Engine.has_singleton("GameState") else ""
	var success: bool = wall_data.buy_side(segment_id, side, buyer_uid, price)
	
	if success:
		# Обновляем визуал через wall_instance
		wall_instance.update_segment_visual(segment_id)
		
		# Можно добавить визуальную обратную связь (анимация, звук и т.д.)
		# print("Purchased segment: ", segment_id, " side: ", side)


func _on_back_button_pressed() -> void:
	# Простая навигация: возвращаемся в главное меню.
	# Путь к сцене главного меню может быть прочитан из GameState
	# или захардкожен/экспортирован в CubeView; в данном прототипе
	# используем явный путь.
	var main_menu_path: String = "res://MainMenu.tscn"
	var err: int = get_tree().change_scene_to_file(main_menu_path)
	if err != OK:
		push_error("CubeView.gd: cannot load main menu: " + main_menu_path)


--- FILE: D:\YandexDisk\Projects\Runner\Godot\CubeView.tscn ---

[gd_scene load_steps=2 format=3 uid="uid://c6cevoyndu48v"]

[ext_resource type="Script" uid="uid://bogcbofaxwviv" path="res://CubeView.gd" id="1_k3bv4"]

[node name="CubeView" type="Node2D"]
script = ExtResource("1_k3bv4")

[node name="Camera2D" type="Camera2D" parent="."]

[node name="GateLine" type="Line2D" parent="."]
points = PackedVector2Array(-10000, 0, 10000, 0)
width = 2.0
default_color = Color(1, 0, 0, 0.7)

[node name="UILayer" type="CanvasLayer" parent="."]

[node name="Panel" type="Panel" parent="UILayer"]
offset_left = 16.0
offset_top = 16.0
offset_right = 260.0
offset_bottom = 140.0

[node name="VBoxContainer" type="VBoxContainer" parent="UILayer/Panel"]
layout_mode = 0
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 8.0
offset_top = 8.0
offset_right = -8.0
offset_bottom = -8.0

[node name="TitleLabel" type="Label" parent="UILayer/Panel/VBoxContainer"]
layout_mode = 2
text = "Cube View"

[node name="BackButton" type="Button" parent="UILayer/Panel/VBoxContainer"]
layout_mode = 2
text = "Back to Menu"


--- FILE: D:\YandexDisk\Projects\Runner\Godot\GameOver.gd ---

extends CanvasLayer

# ============================================================================
# GameOver.gd — UI‑экран завершения забега
# ----------------------------------------------------------------------------
# ОБЯЗАННОСТИ:
# - Показать результаты прошедшего забега:
#   * максимальная достигнутая высота (GameState.max_height_reached)
#   * набранные очки (GameState.score)
# - Дать игроку три варианта:
#   * View Cube    → перейти в CubeView.tscn для просмотра мегакуба
#   * Restart Run  → начать новый забег (Level.tscn)
#   * Main Menu    → вернуться в главное меню (MainMenu.tscn)
#
# ВАЖНО:
# - На этом экране НЕТ игрока, физики и стены. Это чистый UI.
# - GameState.is_game_over на момент входа сюда уже должен быть true и
#   НЕ должен сбрасываться до момента Restart Run.
# - Стена и сегменты продолжают жить в своих сценах (Level / CubeView) и
#   не зависят от этого экрана.
# ============================================================================

@export_file("*.tscn")
var level_scene: String = "res://level.tscn"

@export_file("*.tscn")
var main_menu_scene: String = "res://MainMenu.tscn"

@export_file("*.tscn")
var cube_view_scene: String = "res://CubeView.tscn"

@onready var label_height: Label = $Panel/VBox/HeightLabel
@onready var label_score: Label = $Panel/VBox/ScoreLabel

@onready var button_view_cube: Button = $Panel/VBox/Buttons/ViewCubeButton
@onready var button_restart: Button = $Panel/VBox/Buttons/RestartButton
@onready var button_main_menu: Button = $Panel/VBox/Buttons/MainMenuButton


func _ready() -> void:
	# Подключаем сигналы кнопок один раз при входе на экран.
	if button_view_cube != null and not button_view_cube.pressed.is_connected(_on_view_cube_pressed):
		button_view_cube.pressed.connect(_on_view_cube_pressed)

	if button_restart != null and not button_restart.pressed.is_connected(_on_restart_pressed):
		button_restart.pressed.connect(_on_restart_pressed)

	if button_main_menu != null and not button_main_menu.pressed.is_connected(_on_main_menu_pressed):
		button_main_menu.pressed.connect(_on_main_menu_pressed)

	# ВАЖНО: значения берём ТОЛЬКО из GameState, и только после того,
	# как сцена уже в дереве. Используем отложенный вызов, чтобы не зависеть
	# от порядка _ready у разных нод.
	call_deferred("_update_stats_labels")


func _update_stats_labels() -> void:
	# Если AutoLoad GameState по какой‑то причине не добавлен в дерево
	# (маловероятно в реальной игре, но возможно при F6), просто выходим.
	var gs_node: Node = get_node_or_null("/root/GameState")
	if gs_node == null:
		# Безопасный фоллбек: показываем нули, НО НЕ ТРОГАЕМ GameState.
		if label_height != null and label_height.text == "":
			label_height.text = "Height: 0"
		if label_score != null and label_score.text == "":
			label_score.text = "Score: 0"
		return

	# Основные значения читаем ТОЛЬКО из GameState.
	# Логику подсчёта/сброса не трогаем, только отображаем.

	# 1) SCORE (монеты за забег)
	var score_val: int = 0
	if "last_run_score" in GameState:
		score_val = int(GameState.last_run_score)
	else:
		score_val = int(GameState.score)

	if label_score != null:
		label_score.text = "Score: " + str(score_val)

	# 2) HEIGHT (максимальная достигнутая высота)
	# Предпочитаем last_run_max_height, если есть; иначе max_height_reached.
	var height_val: float = 0.0
	if "last_run_max_height" in GameState:
		height_val = float(GameState.last_run_max_height)
	else:
		height_val = float(GameState.max_height_reached)

	# Если значение никогда не инициализировалось (первый запуск / F6),
	# height_val останется 0. Это честный fallback.
	if label_height != null:
		label_height.text = "Height: " + str(int(abs(height_val)))


func _on_view_cube_pressed() -> void:
	# Переходим в CubeView.tscn для просмотра мегакуба и возможной покупки сегментов.
	# ВАЖНО:
	# - GameState.max_height_reached уже содержит высоту‑гейт для CubeView.
	# - GameState.is_game_over остаётся true; CubeView сам решит, как это использовать
	#   (обычно ему всё равно, он просто читает max_height_reached).
	var target: String = cube_view_scene
	if target == "" or target == null:
		# Если по какой‑то причине путь не задан, логируем ошибку и остаёмся на экране.
		push_error("GameOver.gd: cube_view_scene is not set")
		return

	var err: int = get_tree().change_scene_to_file(target)
	if err != OK:
		push_error("GameOver.gd: cannot load CubeView scene: " + target)


func _on_restart_pressed() -> void:
	# Начинаем НОВЫЙ забег:
	# - сбрасываем GameState (start_new_run)
	# - is_game_over внутри start_new_run устанавливается в false
	# - загружаем Level.tscn
	var gs_node: Node = get_node_or_null("/root/GameState")
	if gs_node == null:
		push_error("GameOver.gd: GameState node not found in scene tree, cannot restart run")
	else:
		# В Godot 4 автозагрузки находятся как /root/GameState, а не через Engine.has_singleton.
		# Поэтому безопасно обращаемся к глобальному GameState и сбрасываем состояние забега.
		GameState.start_new_run()

	var target: String = level_scene
	if target == "" or target == null:
		push_error("GameOver.gd: level_scene is not set")
		return

	var err: int = get_tree().change_scene_to_file(target)
	if err != OK:
		push_error("GameOver.gd: cannot load level scene: " + target)


func _on_main_menu_pressed() -> void:
	# Возврат в главное меню:
	# - ТЕКУЩИЙ забег остаётся завершённым (is_game_over = true).
	# - На следующем старте Play кнопка сама вызовет start_new_run().
	var target: String = main_menu_scene
	if target == "" or target == null:
		push_error("GameOver.gd: main_menu_scene is not set")
		return

	var err: int = get_tree().change_scene_to_file(target)
	if err != OK:
		push_error("GameOver.gd: cannot load main menu: " + target)


--- FILE: D:\YandexDisk\Projects\Runner\Godot\GameOver.tscn ---

[gd_scene load_steps=3 format=3 uid="uid://gvyvc4wckrsu"]

[ext_resource type="Script" uid="uid://b706qiff7x4im" path="res://GameOver.gd" id="1"]
[ext_resource type="Script" path="res://MobileUIScale.gd" id="2_mobile"]

[node name="GameOver" type="CanvasLayer"]
script = ExtResource("1")

[node name="GameOver#MobileScale" type="Node" parent="."]
script = ExtResource("2_mobile")
target_node_path = NodePath("../Panel")

[node name="Panel" type="Panel" parent="."]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 200.0
offset_top = 120.0
offset_right = -200.0
offset_bottom = -120.0

[node name="VBox" type="VBoxContainer" parent="Panel"]
layout_mode = 0
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 24.0
offset_top = 24.0
offset_right = -24.0
offset_bottom = -24.0
theme_override_constants/separation = 16

[node name="TitleLabel" type="Label" parent="Panel/VBox"]
custom_minimum_size = Vector2(0, 60)
layout_mode = 2
theme_override_font_sizes/font_size = 36
text = "GAME OVER"
horizontal_alignment = 1

[node name="HeightLabel" type="Label" parent="Panel/VBox"]
custom_minimum_size = Vector2(0, 40)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Max height (min Y): N/A"

[node name="ScoreLabel" type="Label" parent="Panel/VBox"]
custom_minimum_size = Vector2(0, 40)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Score: 0"

[node name="Buttons" type="HBoxContainer" parent="Panel/VBox"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2
theme_override_constants/separation = 24
alignment = 1

[node name="ViewCubeButton" type="Button" parent="Panel/VBox/Buttons"]
custom_minimum_size = Vector2(220, 64)
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "View Cube"

[node name="RestartButton" type="Button" parent="Panel/VBox/Buttons"]
custom_minimum_size = Vector2(220, 64)
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "Restart Run"

[node name="MainMenuButton" type="Button" parent="Panel/VBox/Buttons"]
custom_minimum_size = Vector2(220, 64)
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "Main Menu"


--- FILE: D:\YandexDisk\Projects\Runner\Godot\GameState.gd ---

extends Node
# ============================================================================
# GameState.gd — Autoload Singleton
# ----------------------------------------------------------------------------
# Хранит:
# - рекорды/таблицу чемпионов
# - выбранного героя
# - настройки кастом-аватара (jump0/jump1)
# - НИКНЕЙМ (persisted) — теперь игра не стартует без него
#
# Закладки под будущий мультиплеер:
# - player_uid (пока локально)
# - auth_provider / auth_token (пока пустые)
# ============================================================================

const SAVE_PATH: String = "user://blackout_run_scores.save"
const MAX_CHAMPIONS: int = 20

const DEFAULT_HERO_ID: String = "default"

# --- PERSISTED PROFILE ---
var nickname: String = ""              # <- ОБЯЗАТЕЛЕН для старта
var player_uid: String = ""            # <- заглушка (мультиплеер)
var auth_provider: String = ""         # <- заглушка (Google/Apple/etc)
var auth_token: String = ""            # <- заглушка

# --- HERO ---
var selected_hero_id: String = DEFAULT_HERO_ID

# --- CUSTOM AVATAR ---
var use_custom_avatar: bool = false
var custom_avatar_up_path: String = "user://avatars/custom_jump_up.png"
var custom_avatar_down_path: String = "user://avatars/custom_jump_down.png"

# --- WALL BREATHING (дыхание мира) ---
var wall_breathing_enabled: bool = true

# --- DEBUG / DEV ---
var disable_wall: bool = false

# --- RUN STATE ---
var score: int = 0
var player_name: String = ""           # имя текущего забега (берём из nickname)
var is_game_over: bool = false         # флаг завершения текущего забега

# --- LAST RUN (для GameOver) ---
# Значения, зафиксированные в момент смерти (Player._die()).
# GameOver читает ТОЛЬКО эти поля — не score и не max_height_reached.
# ДЕФОЛТЫ ОБЯЗАТЕЛЬНЫ: даже без единого забега UI не должен быть пустым.
var last_run_score: int = 0
var last_run_max_height: float = 0.0
var has_finished_run: bool = false

# Максимальная достигнутая высота игрока в world-space (ось Y Godot).
# Принято соглашение:
# - чем МЕНЬШЕ значение Y, тем ВЫШЕ находится игрок (стандартная 2D-координата).
# - max_height_reached хранит МИНИМАЛЬНОЕ значение global_position.y,
#   которого достиг игрок в текущем забеге.
# Это значение используется в CubeView как позиция высотного гейта.
var max_height_reached: float = 0.0

# --- RECORDS ---
var best_score: int = 0
var champions: Array = [] # { "name": String, "score": int, "time": int }

func _ready() -> void:
	load_scores()

# ---------------- PROFILE ----------------

func set_nickname(v: String) -> void:
	nickname = v.strip_edges()
	save_scores()

func get_nickname() -> String:
	return nickname

func has_valid_nickname() -> bool:
	return nickname.strip_edges() != ""

# ---------------- RUN ----------------

func start_new_run() -> void:
	# Имя забега всегда берём из persisted nickname
	score = 0
	player_name = nickname.strip_edges()
	is_game_over = false
	# Сбрасываем высоту; реальное начальное значение задаётся в Player._ready()
	max_height_reached = 0.0
	# last_run_* НЕ сбрасываем: GameOver показывает последний завершённый забег.
	# При первом запуске они уже 0. При следующей смерти Player._die() их перезапишет.

func add_coin(value: int = 1) -> void:
	score += value
	if score > best_score:
		best_score = score

# ---------------- HERO ----------------

func set_selected_hero_id(id: String) -> void:
	var clean_id := id.strip_edges()
	if clean_id == "":
		clean_id = DEFAULT_HERO_ID
	selected_hero_id = clean_id
	save_scores()

func get_selected_hero_id() -> String:
	return selected_hero_id

# ---------------- CUSTOM AVATAR ----------------

func set_use_custom_avatar(v: bool) -> void:
	use_custom_avatar = v
	save_scores()

func get_use_custom_avatar() -> bool:
	return use_custom_avatar

func set_custom_avatar_paths(up_path: String, down_path: String) -> void:
	if up_path.strip_edges() != "":
		custom_avatar_up_path = up_path.strip_edges()
	if down_path.strip_edges() != "":
		custom_avatar_down_path = down_path.strip_edges()
	save_scores()

func get_custom_avatar_up_path() -> String:
	return custom_avatar_up_path

func get_custom_avatar_down_path() -> String:
	return custom_avatar_down_path

# ---------------- WALL BREATHING ----------------

func set_wall_breathing_enabled(v: bool) -> void:
	wall_breathing_enabled = v
	save_scores()

func get_wall_breathing_enabled() -> bool:
	return wall_breathing_enabled

# ---------------- CHAMPIONS ----------------

func register_run_finished() -> void:
	# Фиксируем данные последнего забега ДО добавления в таблицу чемпионов.
	# GameOver читает last_run_score и last_run_max_height — они уже должны быть записаны
	# в Player._die(), но на случай вызова register_run_finished откуда-то ещё — дублируем.
	last_run_score = score
	last_run_max_height = max_height_reached
	has_finished_run = true

	var player_n := player_name.strip_edges()
	if player_n == "":
		player_n = "NoName"

	var entry := {
		"name": player_n,
		"score": score,
		"time": _get_now()
	}

	champions.append(entry)
	champions.sort_custom(Callable(self, "_sort_scores_desc"))

	if champions.size() > MAX_CHAMPIONS:
		champions.resize(MAX_CHAMPIONS)

	save_scores()

func get_champions() -> Array:
	return champions.duplicate()

func reset_scores() -> void:
	score = 0
	best_score = 0
	champions.clear()
	save_scores()

# ---------------- SAVE/LOAD ----------------

func save_scores() -> void:
	var file := FileAccess.open(SAVE_PATH, FileAccess.WRITE)
	if file == null:
		push_error("GameState: не удалось открыть файл для записи: " + SAVE_PATH)
		return

	var data := {
		# profile
		"nickname": nickname,
		"player_uid": player_uid,
		"auth_provider": auth_provider,
		"auth_token": auth_token,

		# records
		"best_score": best_score,
		"champions": champions,

		# hero
		"selected_hero_id": selected_hero_id,

		# custom avatar
		"use_custom_avatar": use_custom_avatar,
		"custom_avatar_up_path": custom_avatar_up_path,
		"custom_avatar_down_path": custom_avatar_down_path,

		# wall breathing
		"wall_breathing_enabled": wall_breathing_enabled
	}

	file.store_var(data)

func load_scores() -> void:
	if not FileAccess.file_exists(SAVE_PATH):
		_reset_to_defaults()
		return

	var file := FileAccess.open(SAVE_PATH, FileAccess.READ)
	if file == null:
		push_error("GameState: не удалось открыть файл для чтения: " + SAVE_PATH)
		_reset_to_defaults()
		return

	var data = file.get_var()
	if typeof(data) != TYPE_DICTIONARY:
		_reset_to_defaults()
		return

	# profile
	nickname = str(data.get("nickname", "")).strip_edges()
	player_uid = str(data.get("player_uid", "")).strip_edges()
	auth_provider = str(data.get("auth_provider", "")).strip_edges()
	auth_token = str(data.get("auth_token", "")).strip_edges()

	# records
	best_score = int(data.get("best_score", 0))

	var loaded_champs = data.get("champions", [])
	champions.clear()
	if typeof(loaded_champs) == TYPE_ARRAY:
		for e in loaded_champs:
			if typeof(e) == TYPE_DICTIONARY:
				champions.append(e)
	champions.sort_custom(Callable(self, "_sort_scores_desc"))
	if champions.size() > MAX_CHAMPIONS:
		champions.resize(MAX_CHAMPIONS)

	# hero
	selected_hero_id = str(data.get("selected_hero_id", DEFAULT_HERO_ID)).strip_edges()
	if selected_hero_id == "":
		selected_hero_id = DEFAULT_HERO_ID

	# custom avatar
	use_custom_avatar = bool(data.get("use_custom_avatar", false))
	custom_avatar_up_path = str(data.get("custom_avatar_up_path", "user://avatars/custom_jump_up.png")).strip_edges()
	custom_avatar_down_path = str(data.get("custom_avatar_down_path", "user://avatars/custom_jump_down.png")).strip_edges()

	if custom_avatar_up_path == "":
		custom_avatar_up_path = "user://avatars/custom_jump_up.png"
	if custom_avatar_down_path == "":
		custom_avatar_down_path = "user://avatars/custom_jump_down.png"

	# wall breathing
	wall_breathing_enabled = bool(data.get("wall_breathing_enabled", true))

func _reset_to_defaults() -> void:
	nickname = ""
	player_uid = ""
	auth_provider = ""
	auth_token = ""

	score = 0
	player_name = ""
	best_score = 0
	champions.clear()

	last_run_score = 0
	last_run_max_height = 0.0
	has_finished_run = false

	selected_hero_id = DEFAULT_HERO_ID

	use_custom_avatar = false
	custom_avatar_up_path = "user://avatars/custom_jump_up.png"
	custom_avatar_down_path = "user://avatars/custom_jump_down.png"

	wall_breathing_enabled = true

func _sort_scores_desc(a: Dictionary, b: Dictionary) -> bool:
	var sa: int = int(a.get("score", 0))
	var sb: int = int(b.get("score", 0))
	if sa == sb:
		var ta: int = int(a.get("time", 0))
		var tb: int = int(b.get("time", 0))
		return ta > tb
	return sa > sb

func _get_now() -> int:
	return Time.get_unix_time_from_system()


--- FILE: D:\YandexDisk\Projects\Runner\Godot\HUD.gd ---

extends Control
# HUD.gd — отображает текущий счёт и имя игрока

@export_file("*.tscn")
var main_menu_scene: String = "res://MainMenu.tscn"

@onready var score_label: Label = $VBoxContainer/ScoreLabel
@onready var name_label: Label = $VBoxContainer/NameLabel
@onready var back_button: Button = $BackButton

func _ready() -> void:
	if back_button != null and not back_button.pressed.is_connected(_on_back_button_pressed):
		back_button.pressed.connect(_on_back_button_pressed)
	_refresh_labels()

func _process(_delta: float) -> void:
	_refresh_labels()

func _refresh_labels() -> void:
	var pn := GameState.player_name
	if pn == "" or pn == "NoName":
		pn = "NoName"
	score_label.text = "Score: " + str(GameState.score)
	name_label.text = "Player: " + pn

func _on_back_button_pressed() -> void:
	if not Engine.is_editor_hint():
		GameState.register_run_finished()
		if main_menu_scene == "":
			push_error("HUD: не задан путь к сцене главного меню (main_menu_scene).")
			return
		var err := get_tree().change_scene_to_file(main_menu_scene)
		if err != OK:
			push_error("HUD: не удалось загрузить сцену главного меню: " + main_menu_scene)


--- FILE: D:\YandexDisk\Projects\Runner\Godot\level.tscn ---

[gd_scene load_steps=12 format=3 uid="uid://dqjhrv658k7px"]

[ext_resource type="Script" uid="uid://b1f0nnjwe1y4n" path="res://scripts/Level.gd" id="1_dp35j"]
[ext_resource type="Script" uid="uid://d2qhqiwwdgihd" path="res://scripts/Player.gd" id="2_hc4jq"]
[ext_resource type="SpriteFrames" uid="uid://c0nyy5461gg26" path="res://heroes/hero_default_jump_frames.tres" id="3_default_frames"]
[ext_resource type="Script" uid="uid://yfnnihpjke51" path="res://HUD.gd" id="4_kqdme"]
[ext_resource type="SpriteFrames" uid="uid://blt1544junb0x" path="res://heroes/hero_monster_jump_frames.tres" id="4_mtnfr"]
[ext_resource type="SpriteFrames" uid="uid://keh6xhe2lv" path="res://heroes/hero_red_jump_frames.tres" id="5_tdk6w"]
[ext_resource type="SpriteFrames" uid="uid://b5liyg33sbvg0" path="res://heroes/hero_blue_jump_frames.tres" id="6_km5ld"]
[ext_resource type="SpriteFrames" uid="uid://cpcmabbbk00du" path="res://heroes/hero_orange_jump_frames.tres" id="7_i2t4f"]
[ext_resource type="PackedScene" uid="uid://dpol13adfo7g3" path="res://wall/wall.tscn" id="8_wall"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_oqtl3"]
size = Vector2(16, 32)

[sub_resource type="SpriteFrames" id="SpriteFrames_pdllj"]
animations = [{
"frames": [],
"loop": true,
"name": &"JUMP",
"speed": 5.0
}]

[node name="Level" type="Node2D"]
script = ExtResource("1_dp35j")

[node name="Platforms" type="Node2D" parent="."]

[node name="Wall" parent="." instance=ExtResource("8_wall")]

[node name="Player" type="CharacterBody2D" parent="."]
position = Vector2(200, 250)
up_direction = Vector2(0, 1)
script = ExtResource("2_hc4jq")
main_menu_scene = "uid://dhfx3og1cf0cj"
frames_default = ExtResource("3_default_frames")
frames_monster = ExtResource("4_mtnfr")
frames_red = ExtResource("5_tdk6w")
frames_blue = ExtResource("6_km5ld")
frames_orange = ExtResource("7_i2t4f")

[node name="Camera2D" type="Camera2D" parent="Player"]
zoom = Vector2(1.2, 1.2)
drag_vertical_enabled = true
drag_top_margin = 0.25
drag_bottom_margin = 0.45
editor_draw_drag_margin = true

[node name="CollisionShape2D" type="CollisionShape2D" parent="Player"]
shape = SubResource("RectangleShape2D_oqtl3")

[node name="AnimatedSprite2D" type="AnimatedSprite2D" parent="Player"]
scale = Vector2(0.6, 0.6)
sprite_frames = SubResource("SpriteFrames_pdllj")
animation = &"JUMP"

[node name="CustomAvatarSprite" type="Sprite2D" parent="Player"]
visible = false
scale = Vector2(0.6, 0.6)

[node name="HUDLayer" type="CanvasLayer" parent="."]

[node name="HUD" type="Control" parent="HUDLayer"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("4_kqdme")

[node name="VBoxContainer" type="VBoxContainer" parent="HUDLayer/HUD"]
layout_mode = 1
offset_left = 16.0
offset_top = 16.0
offset_right = 56.0
offset_bottom = 66.0

[node name="NameLabel" type="Label" parent="HUDLayer/HUD/VBoxContainer"]
layout_mode = 2

[node name="ScoreLabel" type="Label" parent="HUDLayer/HUD/VBoxContainer"]
layout_mode = 2

[node name="BackButton" type="Button" parent="HUDLayer/HUD"]
layout_mode = 1
anchors_preset = 1
anchor_left = 1.0
anchor_right = 1.0
offset_left = -120.0
offset_top = 16.0
offset_right = -67.0
offset_bottom = 47.0
grow_horizontal = 0
text = "Menu"


--- FILE: D:\YandexDisk\Projects\Runner\Godot\LoadingLevel.tscn ---

[gd_scene load_steps=2 format=3 uid="uid://loading_level_scene"]

[ext_resource type="Script" path="res://LoadingLevel.gd" id="1_loading"]

[node name="LoadingLevel" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_loading")

[node name="CenterContainer" type="CenterContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="Label" type="Label" parent="CenterContainer"]
text = "Loading..."



--- FILE: D:\YandexDisk\Projects\Runner\Godot\MainMenu.gd ---

extends Control
# ============================================================================
# MainMenu.gd — ГЛАВНЫЙ ЭКРАН (без настроек аватара)
# ----------------------------------------------------------------------------
# Требования:
# - Play НЕ работает без nickname
# - Champions -> отдельная сцена
# - Profile -> отдельная сцена (там nickname + avatar + jump(0/1))
# - На главном экране показываем текущий аватар (по выбору игрока)
# ============================================================================

@export_file("*.tscn")
var game_scene: String = "res://level.tscn"

@export_file("*.tscn")
var champions_scene: String = "res://Champions.tscn"

@export_file("*.tscn")
var profile_scene: String = "res://Profile.tscn"

@export_file("*.tscn")
var cube_view_scene: String = "res://CubeView.tscn"

@onready var play_button: Button = $RootHBox/LeftPanel/VBoxButtons/PlayButton
@onready var champions_button: Button = $RootHBox/LeftPanel/VBoxButtons/ChampionsButton
@onready var profile_button: Button = $RootHBox/LeftPanel/VBoxButtons/ProfileButton
@onready var cubeview_button: Button = $RootHBox/LeftPanel/VBoxButtons/CubeViewButton

@onready var nickname_label: Label = $RootHBox/LeftPanel/NicknameLabel
@onready var avatar_preview: TextureRect = $RootHBox/RightPanel/AvatarPreview

@onready var warn_dialog: AcceptDialog = $WarnDialog

const HERO_PREVIEWS := {
	"default": "res://heroes/hero_default.png",
	"monster": "res://heroes/hero_monster.png",
	"red": "res://heroes/hero_red.png",
	"blue": "res://heroes/hero_blue.png",
	"orange": "res://heroes/hero_orange.png"
}

func _ready() -> void:
	if play_button and not play_button.pressed.is_connected(_on_play_pressed):
		play_button.pressed.connect(_on_play_pressed)

	if champions_button and not champions_button.pressed.is_connected(_on_champions_pressed):
		champions_button.pressed.connect(_on_champions_pressed)

	if profile_button and not profile_button.pressed.is_connected(_on_profile_pressed):
		profile_button.pressed.connect(_on_profile_pressed)

	if cubeview_button and not cubeview_button.pressed.is_connected(_on_cubeview_pressed):
		cubeview_button.pressed.connect(_on_cubeview_pressed)

	_refresh_ui()

func _process(_delta: float) -> void:
	# лёгкий refresh (тут нет тяжёлых операций)
	_refresh_ui()

func _refresh_ui() -> void:
	var nick := GameState.get_nickname().strip_edges()
	if nickname_label:
		nickname_label.text = "Nickname: " + (nick if nick != "" else "— не задан —")

	# Показываем превью аватара:
	# - если кастом включён и есть файл jump0 -> показываем его
	# - иначе показываем preview выбранного героя
	if avatar_preview == null:
		return

	if GameState.get_use_custom_avatar():
		var up_path := GameState.get_custom_avatar_up_path()
		if FileAccess.file_exists(up_path):
			var img := Image.new()
			var err := img.load(up_path)
			if err == OK:
				var tex := ImageTexture.create_from_image(img)
				avatar_preview.texture = tex
				return

	var hero_id := str(GameState.get_selected_hero_id()).strip_edges()
	if hero_id == "":
		hero_id = "default"
	var p := str(HERO_PREVIEWS.get(hero_id, HERO_PREVIEWS["default"]))
	if p != "" and ResourceLoader.exists(p):
		var res := ResourceLoader.load(p, "", ResourceLoader.CACHE_MODE_REPLACE)
		if res is Texture2D:
			avatar_preview.texture = res

func _on_profile_pressed() -> void:
	var err := get_tree().change_scene_to_file(profile_scene)
	if err != OK:
		push_error("MainMenu.gd: не удалось открыть Profile: " + profile_scene)

func _on_champions_pressed() -> void:
	var err := get_tree().change_scene_to_file(champions_scene)
	if err != OK:
		push_error("MainMenu.gd: не удалось открыть Champions: " + champions_scene)


func _on_cubeview_pressed() -> void:
	# ----------------------------------------------------------------------------
	# ПЕРЕХОД В СЦЕНУ ПРОСМОТРА СТЕНЫ (CubeView)
	# ----------------------------------------------------------------------------
	# Эта кнопка позволяет игроку открыть сцену CubeView,
	# где он может рассматривать мегакуб и взаимодействовать с сегментами
	# в спокойном режиме, вне игрового раннера.
	# Здесь мы просто меняем сцену на CubeView.tscn.
	# ВАЖНО: логика стены и сегментов внутри CubeView остаётся той же,
	# что и в Level — мы лишь меняем окружение.
	# ----------------------------------------------------------------------------
	var err := get_tree().change_scene_to_file(cube_view_scene)
	if err != OK:
		push_error("MainMenu.gd: не удалось открыть CubeView: " + cube_view_scene)

func _on_play_pressed() -> void:
	# Запрет старта без nickname
	if not GameState.has_valid_nickname():
		_show_warn("Сначала нужно указать никнейм (Profile).")
		return

	# старт забега
	GameState.start_new_run()

	var err := get_tree().change_scene_to_file(game_scene)
	if err != OK:
		push_error("MainMenu.gd: не удалось загрузить сцену игры: " + game_scene)

func _show_warn(text: String) -> void:
	if warn_dialog:
		warn_dialog.dialog_text = text
		warn_dialog.popup_centered()


--- FILE: D:\YandexDisk\Projects\Runner\Godot\MainMenu.tscn ---

[gd_scene load_steps=2 format=3 uid="uid://dhfx3og1cf0cj"]

[ext_resource type="Script" uid="uid://bccj45bqt7cxy" path="res://MainMenu.gd" id="1_nsm8v"]

[node name="MainMenu" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_nsm8v")

[node name="RootHBox" type="HBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 0

[node name="LeftPanel" type="Panel" parent="RootHBox"]
custom_minimum_size = Vector2(480, 0)
layout_mode = 2

[node name="RightPanel" type="CenterContainer" parent="RootHBox"]
layout_mode = 2
size_flags_horizontal = 3

[node name="NicknameLabel" type="Label" parent="RootHBox/LeftPanel"]
layout_mode = 1
anchors_preset = 10
anchor_left = 0.0
anchor_top = 0.0
anchor_right = 1.0
anchor_bottom = 0.0
offset_left = 24.0
offset_top = 24.0
offset_right = -24.0
custom_minimum_size = Vector2(0, 40)
text = "Nickname: —"

[node name="VBoxButtons" type="VBoxContainer" parent="RootHBox/LeftPanel"]
layout_mode = 1
anchors_preset = 8
anchor_left = 0.0
anchor_top = 0.0
anchor_right = 0.0
anchor_bottom = 1.0
offset_left = 24.0
offset_top = 80.0
offset_right = 304.0
offset_bottom = -24.0
grow_vertical = 2
theme_override_constants/separation = 14

[node name="TitleLabel" type="Label" parent="RootHBox/LeftPanel/VBoxButtons"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2
theme_override_font_sizes/font_size = 32
text = "BLACKOUT RUN"

[node name="PlayButton" type="Button" parent="RootHBox/LeftPanel/VBoxButtons"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2
theme_override_font_sizes/font_size = 32
text = "Play"

[node name="ChampionsButton" type="Button" parent="RootHBox/LeftPanel/VBoxButtons"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2
theme_override_font_sizes/font_size = 32
text = "Champions"

[node name="ProfileButton" type="Button" parent="RootHBox/LeftPanel/VBoxButtons"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2
theme_override_font_sizes/font_size = 32
text = "Profile / Settings"

[node name="CubeViewButton" type="Button" parent="RootHBox/LeftPanel/VBoxButtons"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2
theme_override_font_sizes/font_size = 32
text = "View Cube"

[node name="AvatarPreview" type="TextureRect" parent="RootHBox/RightPanel"]
custom_minimum_size = Vector2(504, 504)
layout_mode = 2
expand_mode = 1
stretch_mode = 5

[node name="WarnDialog" type="AcceptDialog" parent="."]
oversampling_override = 1.0
title = "Внимание"
dialog_text = "..."


--- FILE: D:\YandexDisk\Projects\Runner\Godot\MobileUIScale.gd ---

extends Node
# ============================================================================
# MobileUIScale.gd
# ----------------------------------------------------------------------------
# Простой вспомогательный узел, который масштабирует целевой UI‑элемент
# (обычно `Panel` / `Control`) под размер экрана мобильных устройств.
#
# ВАЖНО:
# - Скрипт НИЧЕГО не меняет в геймплее.
# - Работает только с размером и масштабом UI.
# - Если целевой узел не найден, просто пишет предупреждение и ничего не делает.
# ============================================================================

@export var target_node_path: NodePath = NodePath(".")

# Базовое разрешение, под которое верстался UI в эталоне.
const BASE_WIDTH := 1080.0
const BASE_HEIGHT := 1920.0


func _ready() -> void:
	var target := get_node_or_null(target_node_path)
	if target == null:
		push_warning("MobileUIScale: target node not found: " + str(target_node_path))
		return

	if not (target is Control):
		push_warning("MobileUIScale: target is not Control: " + str(target))
		return

	# Текущий размер экрана / окна
	var viewport_size: Vector2 = get_viewport().get_visible_rect().size
	if viewport_size.x <= 0.0 or viewport_size.y <= 0.0:
		return

	# На десктопе оставляем исходный размер UI, масштабируем только на мобильных
	var os_name := OS.get_name()
	if os_name != "Android" and os_name != "iOS":
		target.scale = Vector2.ONE
		return

	# Рассчитываем коэффициенты масштабирования по ширине/высоте
	var scale_x := viewport_size.x / BASE_WIDTH
	var scale_y := viewport_size.y / BASE_HEIGHT

	# Берём минимальный коэффициент, чтобы UI влезал целиком
	var k := float(min(scale_x, scale_y))
	# Небольшой "коридор", чтобы на десктопе не было гигантского UI
	# - Если k < 0.9 — масштабируем до мобильного
	# - Если k в [0.9; 1.1] — оставляем как есть
	# - Если k > 1.1 — слегка уменьшаем, чтобы не раздувать интерфейс
	if k < 0.9:
		target.scale = Vector2(k, k)
	elif k > 1.1:
		var desk: float = lerp(1.0, k, 0.3)
		target.scale = Vector2(desk, desk)
	else:
		target.scale = Vector2.ONE


--- FILE: D:\YandexDisk\Projects\Runner\Godot\Platform.tscn ---

[gd_scene load_steps=3 format=3 uid="uid://be75ddpx283h6"]

[ext_resource type="Script" uid="uid://d3vnfw24h7bdb" path="res://scripts/Platform.gd" id="1_hyugo"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_s2m6q"]
size = Vector2(32, 32)

[node name="Platform" type="StaticBody2D"]
constant_linear_velocity = Vector2(64, 64)
script = ExtResource("1_hyugo")
coin_spawn_chance = 0.3

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_s2m6q")


--- FILE: D:\YandexDisk\Projects\Runner\Godot\Profile.gd ---

extends Control
# ============================================================================
# Profile.gd — отдельная сцена профиля игрока (nickname + выбор героя + кастом-аватар jump(0/1))
# ----------------------------------------------------------------------------
# ТРЕБОВАНИЕ (твое):
# ✅ Любая картинка, которую загружает ИГРОК (png/jpg/jpeg), должна в игре быть 64x64
#    БЕЗ ОБРЕЗКИ — только уменьшение/вписывание с сохранением пропорций.
#
# КАК ЭТО РЕШЕНО (без ломания твоей логики и без влияния на встроенных героев):
# 1) При выборе файла (jump0/jump1) мы загружаем Image из исходника (png/jpg/jpeg).
# 2) Вписываем в квадрат 64x64 (прозрачный фон), без обрезки.
# 3) Сохраняем в user://avatars/custom_jump_up.png и custom_jump_down.png.
# 4) GameState пути оставляем как у тебя (ничего не ломаем).
#
# ВАЖНО:
# - Встроенные спрайты героев (которые ты задаёшь в инспекторе) НЕ трогаем.
# - Меняем ТОЛЬКО то, что загрузил игрок.
# ============================================================================

@export_file("*.tscn")
var main_menu_scene: String = "res://MainMenu.tscn"

@onready var nickname_edit: LineEdit = $CenterContainer/Panel/VBoxContainer/NicknameEdit
@onready var save_button: Button = $CenterContainer/Panel/VBoxContainer/ButtonsRow/SaveButton
@onready var back_button: Button = $CenterContainer/Panel/VBoxContainer/ButtonsRow/BackButton

@onready var hero_left_button: Button = $CenterContainer/Panel/VBoxContainer/HeroSelector/HeroLeftButton
@onready var hero_right_button: Button = $CenterContainer/Panel/VBoxContainer/HeroSelector/HeroRightButton
@onready var hero_preview: TextureRect = $CenterContainer/Panel/VBoxContainer/HeroSelector/HeroPreview
@onready var hero_name_label: Label = $CenterContainer/Panel/VBoxContainer/HeroSelector/HeroNameLabel

@onready var custom_avatar_check: CheckBox = $CenterContainer/Panel/VBoxContainer/CustomAvatarRow/CustomAvatarCheck
@onready var wall_breathing_check: CheckBox = $CenterContainer/Panel/VBoxContainer/WallBreathingCheck
@onready var upload_jump_up_button: Button = $CenterContainer/Panel/VBoxContainer/CustomAvatarRow/UploadJumpUpButton
@onready var upload_jump_down_button: Button = $CenterContainer/Panel/VBoxContainer/CustomAvatarRow/UploadJumpDownButton

@onready var file_dialog_jump_up: FileDialog = $FileDialogJumpUp
@onready var file_dialog_jump_down: FileDialog = $FileDialogJumpDown

@onready var warn_dialog: AcceptDialog = $WarnDialog

const HEROES: Array = [
	{"id": "default", "name": "Runner AYO", "preview_png": "res://heroes/hero_default.png"},
	{"id": "monster", "name": "Monster",    "preview_png": "res://heroes/hero_monster.png"},
	{"id": "red",     "name": "Red",        "preview_png": "res://heroes/hero_red.png"},
	{"id": "blue", "name": "Blue",   	 	"preview_png": "res://heroes/hero_blue.png"},
	{"id": "orange", "name": "Orange",  	"preview_png": "res://heroes/hero_orange.png"}
]

const AVATAR_DIR: String = "user://avatars"
const AVATAR_UP_PNG: String = "user://avatars/custom_jump_up.png"
const AVATAR_DOWN_PNG: String = "user://avatars/custom_jump_down.png"

# Целевой размер пользовательских аватарок (то, что загрузил игрок)
const AVATAR_TARGET_SIZE_PX: int = 64

var _hero_index: int = 0

func _ready() -> void:
	# --- nickname ---
	if nickname_edit:
		nickname_edit.text = GameState.get_nickname()
		nickname_edit.grab_focus()

	# --- buttons ---
	if save_button and not save_button.pressed.is_connected(_on_save_pressed):
		save_button.pressed.connect(_on_save_pressed)

	if back_button and not back_button.pressed.is_connected(_on_back_pressed):
		back_button.pressed.connect(_on_back_pressed)

	# --- heroes ---
	if hero_left_button and not hero_left_button.pressed.is_connected(_on_hero_left_pressed):
		hero_left_button.pressed.connect(_on_hero_left_pressed)

	if hero_right_button and not hero_right_button.pressed.is_connected(_on_hero_right_pressed):
		hero_right_button.pressed.connect(_on_hero_right_pressed)

	var saved_id: String = str(GameState.get_selected_hero_id())
	_hero_index = _find_hero_index_by_id(saved_id)
	_apply_hero_to_ui()

	# --- custom avatar ---
	if custom_avatar_check:
		custom_avatar_check.button_pressed = bool(GameState.get_use_custom_avatar())
		if not custom_avatar_check.toggled.is_connected(_on_custom_avatar_toggled):
			custom_avatar_check.toggled.connect(_on_custom_avatar_toggled)

	if wall_breathing_check:
		wall_breathing_check.button_pressed = bool(GameState.get_wall_breathing_enabled())
		if not wall_breathing_check.toggled.is_connected(_on_wall_breathing_toggled):
			wall_breathing_check.toggled.connect(_on_wall_breathing_toggled)

	if upload_jump_up_button and not upload_jump_up_button.pressed.is_connected(_on_upload_jump_up_pressed):
		upload_jump_up_button.pressed.connect(_on_upload_jump_up_pressed)

	if upload_jump_down_button and not upload_jump_down_button.pressed.is_connected(_on_upload_jump_down_pressed):
		upload_jump_down_button.pressed.connect(_on_upload_jump_down_pressed)

	# dialogs signals
	if file_dialog_jump_up and not file_dialog_jump_up.file_selected.is_connected(_on_jump_up_file_selected):
		file_dialog_jump_up.file_selected.connect(_on_jump_up_file_selected)

	if file_dialog_jump_down and not file_dialog_jump_down.file_selected.is_connected(_on_jump_down_file_selected):
		file_dialog_jump_down.file_selected.connect(_on_jump_down_file_selected)

	# Desktop: native dialog (Windows/macOS/Linux)
	# Примечание: на Android/iOS может быть не fully-native без плагина — это нормально.
	if file_dialog_jump_up:
		file_dialog_jump_up.use_native_dialog = true
	if file_dialog_jump_down:
		file_dialog_jump_down.use_native_dialog = true

	_update_custom_avatar_buttons_state()

func _unhandled_input(event: InputEvent) -> void:
	if event is InputEventKey and event.pressed and event.keycode == KEY_ESCAPE:
		_on_back_pressed()

# ---------------- HERO SELECTOR ----------------

func _find_hero_index_by_id(id: String) -> int:
	var clean_id: String = id.strip_edges()
	if clean_id == "":
		return 0
	for i in range(HEROES.size()):
		var h = HEROES[i]
		if typeof(h) == TYPE_DICTIONARY and str(h.get("id", "")) == clean_id:
			return int(i)
	return 0

func _apply_hero_to_ui() -> void:
	if HEROES.is_empty():
		return

	if _hero_index < 0:
		_hero_index = HEROES.size() - 1
	if _hero_index >= HEROES.size():
		_hero_index = 0

	var hero = HEROES[_hero_index]
	if typeof(hero) != TYPE_DICTIONARY:
		return

	var hero_display_name: String = str(hero.get("name", "Hero"))
	if hero_name_label:
		hero_name_label.text = hero_display_name

	var preview_path: String = str(hero.get("preview_png", ""))
	if hero_preview:
		if preview_path != "" and ResourceLoader.exists(preview_path):
			var res := ResourceLoader.load(preview_path, "", ResourceLoader.CACHE_MODE_REPLACE)
			if res is Texture2D:
				hero_preview.texture = res

func _save_current_hero_to_gamestate() -> void:
	if HEROES.is_empty():
		return
	var hero = HEROES[_hero_index]
	if typeof(hero) != TYPE_DICTIONARY:
		return

	var hero_id: String = str(hero.get("id", "default")).strip_edges()
	if hero_id == "":
		hero_id = "default"

	GameState.set_selected_hero_id(hero_id)

func _on_hero_left_pressed() -> void:
	_hero_index -= 1
	if _hero_index < 0:
		_hero_index = HEROES.size() - 1
	_apply_hero_to_ui()
	_save_current_hero_to_gamestate()

func _on_hero_right_pressed() -> void:
	_hero_index += 1
	if _hero_index >= HEROES.size():
		_hero_index = 0
	_apply_hero_to_ui()
	_save_current_hero_to_gamestate()

# ---------------- CUSTOM AVATAR ----------------

func _on_custom_avatar_toggled(pressed: bool) -> void:
	GameState.set_use_custom_avatar(pressed)
	_update_custom_avatar_buttons_state()

func _on_wall_breathing_toggled(pressed: bool) -> void:
	GameState.set_wall_breathing_enabled(pressed)

func _update_custom_avatar_buttons_state() -> void:
	var enabled := custom_avatar_check != null and custom_avatar_check.button_pressed

	if upload_jump_up_button:
		upload_jump_up_button.disabled = not enabled
	if upload_jump_down_button:
		upload_jump_down_button.disabled = not enabled

func _on_upload_jump_up_pressed() -> void:
	if file_dialog_jump_up:
		file_dialog_jump_up.popup_centered_ratio(0.85)

func _on_upload_jump_down_pressed() -> void:
	if file_dialog_jump_down:
		file_dialog_jump_down.popup_centered_ratio(0.85)

func _ensure_user_avatar_dir() -> void:
	# Создаём user://avatars если его нет
	if not DirAccess.dir_exists_absolute(AVATAR_DIR):
		var mk_err: int = DirAccess.make_dir_recursive_absolute(AVATAR_DIR)
		if mk_err != OK:
			push_warning("Profile.gd: не удалось создать папку: " + AVATAR_DIR + " err=" + str(mk_err))

func _import_image_as_png_to_user(source_path: String, target_user_png_path: String) -> bool:
	# Ключевая логика:
	# 1) грузим картинку (png/jpg/jpeg)
	# 2) вписываем в квадрат 64x64 без обрезки
	# 3) сохраняем как PNG в user://avatars/...
	_ensure_user_avatar_dir()

	var img: Image = Image.new()
	var err_load: int = img.load(source_path)
	if err_load != OK:
		push_warning("Profile.gd: не удалось загрузить изображение: " + source_path + " err=" + str(err_load))
		return false

	# Приводим к RGBA8 (для корректной работы с прозрачностью/ресайзом)
	if img.get_format() != Image.FORMAT_RGBA8:
		img.convert(Image.FORMAT_RGBA8)

	# Вписываем в 64x64 (прозрачные поля по бокам/сверху если нужно)
	var fitted: Image = _fit_image_into_square(img, AVATAR_TARGET_SIZE_PX)

	# Сохраняем уже НОРМАЛЬНЫЙ PNG (и всегда 64x64)
	var err_save: int = fitted.save_png(target_user_png_path)
	if err_save != OK:
		push_warning("Profile.gd: не удалось сохранить PNG в: " + target_user_png_path + " err=" + str(err_save))
		return false

	return true

func _on_jump_up_file_selected(path: String) -> void:
	var ok := _import_image_as_png_to_user(path, AVATAR_UP_PNG)
	if ok:
		GameState.set_custom_avatar_paths(AVATAR_UP_PNG, GameState.get_custom_avatar_down_path())
	else:
		_show_warn("Не удалось загрузить jump(0). Попробуй PNG/JPG/JPEG без повреждений.")

func _on_jump_down_file_selected(path: String) -> void:
	var ok := _import_image_as_png_to_user(path, AVATAR_DOWN_PNG)
	if ok:
		GameState.set_custom_avatar_paths(GameState.get_custom_avatar_up_path(), AVATAR_DOWN_PNG)
	else:
		_show_warn("Не удалось загрузить jump(1). Попробуй PNG/JPG/JPEG без повреждений.")

# ---------------- SAVE / BACK ----------------

func _on_save_pressed() -> void:
	var nick := ""
	if nickname_edit:
		nick = nickname_edit.text.strip_edges()

	if nick == "":
		_show_warn("Нужно заполнить никнейм!")
		return

	GameState.set_nickname(nick)
	_save_current_hero_to_gamestate()

	# сохраняем переключатель «дыхание мира»
	if wall_breathing_check:
		GameState.set_wall_breathing_enabled(wall_breathing_check.button_pressed)

	# если пользователь включил кастом-аватар — проверим что файлы существуют
	if GameState.get_use_custom_avatar():
		var up_ok := FileAccess.file_exists(GameState.get_custom_avatar_up_path())
		var dn_ok := FileAccess.file_exists(GameState.get_custom_avatar_down_path())
		if not up_ok or not dn_ok:
			_show_warn("Кастом-аватар включён, но jump(0) или jump(1) не загружены.")
			return

	_on_back_pressed()

func _on_back_pressed() -> void:
	var err := get_tree().change_scene_to_file(main_menu_scene)
	if err != OK:
		push_error("Profile.gd: не удалось вернуться в меню: " + main_menu_scene)

func _show_warn(text: String) -> void:
	if warn_dialog:
		warn_dialog.dialog_text = text
		warn_dialog.popup_centered()
	else:
		push_warning("WARN: " + text)

# ---------------- IMAGE HELPERS ----------------

func _fit_image_into_square(src: Image, target_size: int) -> Image:
	# Вписываем изображение в квадрат target_size x target_size БЕЗ ОБРЕЗКИ.
	# - сохраняем пропорции
	# - добавляем прозрачные поля где нужно
	# - итог всегда ровно target_size x target_size
	var src_w: int = src.get_width()
	var src_h: int = src.get_height()

	if src_w <= 0 or src_h <= 0:
		return src

	var dst: Image = Image.create(target_size, target_size, false, Image.FORMAT_RGBA8)
	dst.fill(Color(0, 0, 0, 0))

	# Работаем с копией, чтобы не портить исходный Image
	var resized: Image = src.duplicate()
	if resized.get_format() != Image.FORMAT_RGBA8:
		resized.convert(Image.FORMAT_RGBA8)

	# Масштаб "вписать"
	var scale: float = minf(float(target_size) / float(src_w), float(target_size) / float(src_h))

	# Даже если картинка маленькая — всё равно приведём к предсказуемому размеру (64x64)
	var new_w: int = maxi(1, int(round(float(src_w) * scale)))
	var new_h: int = maxi(1, int(round(float(src_h) * scale)))

	resized.resize(new_w, new_h, Image.INTERPOLATE_LANCZOS)

	# Центрируем
	var x: int = int((target_size - new_w) / 2)
	var y: int = int((target_size - new_h) / 2)

	dst.blit_rect(resized, Rect2i(0, 0, new_w, new_h), Vector2i(x, y))
	return dst


--- FILE: D:\YandexDisk\Projects\Runner\Godot\Profile.tscn ---

[gd_scene load_steps=2 format=3 uid="uid://dg133jef00bhu"]

[ext_resource type="Script" uid="uid://ce7583hntybfd" path="res://Profile.gd" id="1_profile"]

[node name="Profile" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_profile")

[node name="CenterContainer" type="CenterContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="Panel" type="Panel" parent="CenterContainer"]
custom_minimum_size = Vector2(900, 620)
layout_mode = 2

[node name="VBoxContainer" type="VBoxContainer" parent="CenterContainer/Panel"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 24.0
offset_top = 24.0
offset_right = -24.0
offset_bottom = -24.0
grow_horizontal = 2
grow_vertical = 2

[node name="TitleLabel" type="Label" parent="CenterContainer/Panel/VBoxContainer"]
layout_mode = 2
theme_override_font_sizes/font_size = 32
text = "Profile"

[node name="NicknameEdit" type="LineEdit" parent="CenterContainer/Panel/VBoxContainer"]
custom_minimum_size = Vector2(0, 72)
layout_mode = 2
theme_override_font_sizes/font_size = 28
placeholder_text = "Введите никнейм"

[node name="HeroSelector" type="HBoxContainer" parent="CenterContainer/Panel/VBoxContainer"]
layout_mode = 2
theme_override_constants/separation = 16
alignment = 1

[node name="HeroLeftButton" type="Button" parent="CenterContainer/Panel/VBoxContainer/HeroSelector"]
layout_mode = 2
text = "<"

[node name="HeroPreview" type="TextureRect" parent="CenterContainer/Panel/VBoxContainer/HeroSelector"]
custom_minimum_size = Vector2(110, 110)
layout_mode = 2
expand_mode = 1
stretch_mode = 5

[node name="HeroRightButton" type="Button" parent="CenterContainer/Panel/VBoxContainer/HeroSelector"]
layout_mode = 2
text = ">"

[node name="HeroNameLabel" type="Label" parent="CenterContainer/Panel/VBoxContainer/HeroSelector"]
layout_mode = 2
text = "Runner AYO"

[node name="CustomAvatarRow" type="VBoxContainer" parent="CenterContainer/Panel/VBoxContainer"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="CustomAvatarCheck" type="CheckBox" parent="CenterContainer/Panel/VBoxContainer/CustomAvatarRow"]
layout_mode = 2
text = "Свой аватар (2 фото: jump0/jump1)"

[node name="UploadJumpUpButton" type="Button" parent="CenterContainer/Panel/VBoxContainer/CustomAvatarRow"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
text = "Загрузить jump(0)"

[node name="UploadJumpDownButton" type="Button" parent="CenterContainer/Panel/VBoxContainer/CustomAvatarRow"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
text = "Загрузить jump(1)"

[node name="WallBreathingCheck" type="CheckBox" parent="CenterContainer/Panel/VBoxContainer"]
layout_mode = 2
text = "Дыхание мира (анимация стены)"

[node name="ButtonsRow" type="HBoxContainer" parent="CenterContainer/Panel/VBoxContainer"]
layout_mode = 2
theme_override_constants/separation = 16
alignment = 1

[node name="SaveButton" type="Button" parent="CenterContainer/Panel/VBoxContainer/ButtonsRow"]
custom_minimum_size = Vector2(240, 64)
layout_mode = 2
text = "Save"

[node name="BackButton" type="Button" parent="CenterContainer/Panel/VBoxContainer/ButtonsRow"]
custom_minimum_size = Vector2(240, 64)
layout_mode = 2
text = "Back"

[node name="FileDialogJumpUp" type="FileDialog" parent="."]
title = "Open a File"
ok_button_text = "Открыть"
dialog_hide_on_ok = true
file_mode = 0
access = 2
filters = PackedStringArray("*.png ; PNG Images", "*.jpg ; JPG Images", "*.jpeg ; JPEG Images")

[node name="FileDialogJumpDown" type="FileDialog" parent="."]
title = "Open a File"
ok_button_text = "Открыть"
dialog_hide_on_ok = true
file_mode = 0
access = 2
filters = PackedStringArray("*.png ; PNG Images", "*.jpg ; JPG Images", "*.jpeg ; JPEG Images")

[node name="WarnDialog" type="AcceptDialog" parent="."]
title = "Внимание"
dialog_text = "..."


--- FILE: D:\YandexDisk\Projects\Runner\Godot\scripts\Level.gd ---

extends Node2D
# Level.gd — твой фундамент + безопасное чтение параметров Player через get()

@onready var player: CharacterBody2D = $Player
@onready var platforms_root: Node2D = $Platforms

var platform_scene: PackedScene = preload("res://Platform.tscn")
var rng: RandomNumberGenerator = RandomNumberGenerator.new()

const TILE_SIZE: float = 64.0
const PLATFORM_HEIGHT: float = 64.0

const MAIN_MIN_SEGMENTS: int = 2
const MAIN_MAX_SEGMENTS: int = 6

const DECOY_MIN_SEGMENTS: int = 1
const DECOY_MAX_SEGMENTS: int = 10

const SAFE_MAIN_GAP_X: float = 220.0

const MIN_EDGE_GAP: float = 32.0
const MAX_EDGE_GAP: float = SAFE_MAIN_GAP_X

const MIN_VERTICAL_GAP: float = 32.0
const MIN_TOTAL_PLATFORMS: int = 10

const PLAYER_SPEED_X: float = 350.0
const SEGMENT_TIME_SECONDS: float = 7.0 * 60.0
const WORLD_WIDTH: float = PLAYER_SPEED_X * SEGMENT_TIME_SECONDS
const LEFT_WALL_X: float = 0.0
const RIGHT_WALL_X: float = WORLD_WIDTH

const DY_STEP: float = 64.0

const DECOY_OFFSET_X_MIN: float = SAFE_MAIN_GAP_X * 1.6
const DECOY_OFFSET_X_MAX: float = SAFE_MAIN_GAP_X * 2.0

@export var WORLD_SCREENS: int = 20
@export var USE_FIXED_WORLD_WIDTH: bool = false
@export var FIXED_WORLD_WIDTH: float = 8000.0
@export var HORIZONTAL_WORLD_MARGIN: float = 256.0

const SAFE_MARGIN_X: float = 32.0

@export var DIFFICULTY_PER_STEP: float = 0.0025
@export var DIFFICULTY_START: float = 0.01
@export var DIFFICULTY_MAX: float = 0.1
var difficulty: float = 0.0

@export var GAP_MIN_PCT_EASY: float = 0.20
@export var GAP_MAX_PCT_EASY: float = 0.55
@export var GAP_MIN_PCT_HARD: float = 0.45
@export var GAP_MAX_PCT_HARD: float = 0.90

@export var MIN_MAIN_EDGE_GAP_ABS: float = 100.0
@export var MAX_MAIN_EDGE_GAP_ABS: float = 260.0

var viewport_width: float = 0.0
var viewport_height: float = 0.0

var min_center_x: float = 0.0
var max_center_x: float = 0.0

var platforms: Array[Node2D] = []

var last_main_pos: Vector2 = Vector2.ZERO
var last_main_segments: int = 4

var going_right: bool = true

var wall_clamp_count: int = 0
const WALL_CLAMP_THRESHOLD: int = 2

@export var DEBUG_LOG: bool = true

func _ready() -> void:
	rng.randomize()

	var viewport_size: Vector2 = get_viewport().get_visible_rect().size
	viewport_width = viewport_size.x
	viewport_height = viewport_size.y
	
	var world_left: float = LEFT_WALL_X
	var world_right: float = RIGHT_WALL_X

	if USE_FIXED_WORLD_WIDTH:
		world_right = world_left + max(0.0, FIXED_WORLD_WIDTH)
	else:
		var screens_width: float = max(1, WORLD_SCREENS) * viewport_width
		world_right = world_left + screens_width

	min_center_x = world_left + HORIZONTAL_WORLD_MARGIN
	max_center_x = world_right - HORIZONTAL_WORLD_MARGIN

	if max_center_x <= min_center_x:
		var safe_margin_try: float = max(8.0, viewport_width * 0.1)
		min_center_x = world_left + safe_margin_try
		max_center_x = world_right - safe_margin_try

	var start_x: float = clamp(min_center_x + 200.0, min_center_x, max_center_x)
	var start_y: float = viewport_height - 200.0
	if player:
		player.global_position = Vector2(start_x, start_y)
	else:
		push_error("Level.gd: player node not found at $Player")

	difficulty = clamp(DIFFICULTY_START, 0.0, DIFFICULTY_MAX)

	for child in platforms_root.get_children():
		child.queue_free()
	platforms.clear()

	_create_initial_platforms()

func _physics_process(_delta: float) -> void:
	# ВАЖНО: сначала проверяем is_game_over, чтобы после смерти
	# не было лишних обновлений.
	if Engine.has_singleton("GameState") and GameState.is_game_over:
		return
	_update_platforms_around_player()

# --- FIX: безопасно читаем export-поля Player.gd через get() ---
func _get_player_param_float(param_name: String, fallback_value: float) -> float:
	if player == null:
		return fallback_value
	var v: Variant = player.get(param_name)
	if v == null:
		return fallback_value
	return float(v)

func _max_horizontal_reach(start_surface_y: float, target_surface_y: float, v_jump: float, g: float, v_x: float) -> float:
	var delta_y: float = target_surface_y - start_surface_y
	var disc: float = v_jump * v_jump + 2.0 * g * delta_y
	if disc < 0.0:
		return 0.0
	var t: float = (-v_jump + sqrt(disc)) / g
	return abs(v_x) * t

func _can_place_platform_at(pos: Vector2, segments: int) -> bool:
	var half_new_x: float = float(segments) * TILE_SIZE * 0.5
	for p in platforms:
		if not p:
			continue
		var existing_segments: int = max(1, int(round(p.scale.x)))
		var half_ex_x: float = float(existing_segments) * TILE_SIZE * 0.5
		var dx: float = abs(pos.x - p.global_position.x)
		var dy: float = abs(pos.y - p.global_position.y)
		var min_allowed_dx: float = half_new_x + half_ex_x + MIN_EDGE_GAP
		var min_allowed_dy: float = PLATFORM_HEIGHT + MIN_VERTICAL_GAP
		if dx < min_allowed_dx and dy < min_allowed_dy:
			return false
	return true

func _create_initial_platforms() -> void:
	var start_platform_pos: Vector2 = player.global_position + Vector2(0.0, 80.0)
	var initial_segments: int = 4
	_spawn_main_platform_at(start_platform_pos, initial_segments)

	going_right = true
	for _i in range(MIN_TOTAL_PLATFORMS - 1):
		_spawn_next_step()

func _spawn_main_platform_at(pos: Vector2, segments: int) -> Node2D:
	var clamped_segments: int = clamp(segments, MAIN_MIN_SEGMENTS, MAIN_MAX_SEGMENTS)
	var adjusted_pos: Vector2 = pos
	var attempts: int = 0
	while attempts < 6 and not _can_place_platform_at(adjusted_pos, clamped_segments):
		adjusted_pos.y -= PLATFORM_HEIGHT + MIN_VERTICAL_GAP
		attempts += 1

	var p: Node2D = platform_scene.instantiate()
	platforms_root.add_child(p)
	p.global_position = adjusted_pos
	p.scale.x = float(clamped_segments)
	platforms.append(p)

	last_main_segments = clamped_segments
	last_main_pos = adjusted_pos

	return p

func _spawn_next_step() -> void:
	difficulty = clamp(difficulty + DIFFICULTY_PER_STEP, 0.0, DIFFICULTY_MAX)

	var seg_main: int = rng.randi_range(MAIN_MIN_SEGMENTS, MAIN_MAX_SEGMENTS)
	var half_prev: float = float(last_main_segments) * TILE_SIZE * 0.5
	var half_new: float = float(seg_main) * TILE_SIZE * 0.5

	var new_y: float = last_main_pos.y - DY_STEP

	var start_surface_y: float = last_main_pos.y - PLATFORM_HEIGHT * 0.5
	var target_surface_y: float = new_y - PLATFORM_HEIGHT * 0.5

	var p_jump: float = _get_player_param_float("JUMP_VELOCITY", -960.0)
	var p_grav: float = _get_player_param_float("GRAVITY", 2600.0)
	var p_speed: float = _get_player_param_float("MOVE_SPEED", 260.0)

	var reach: float = _max_horizontal_reach(start_surface_y, target_surface_y, p_jump, p_grav, p_speed)

	var max_edge_gap_physical: float = max(0.0, reach - SAFE_MARGIN_X - half_new)

	var cur_min_pct: float = lerp(GAP_MIN_PCT_EASY, GAP_MIN_PCT_HARD, difficulty)
	var cur_max_pct: float = lerp(GAP_MAX_PCT_EASY, GAP_MAX_PCT_HARD, difficulty)
	if cur_max_pct < cur_min_pct:
		var tmp: float = cur_min_pct
		cur_min_pct = cur_max_pct
		cur_max_pct = tmp

	var desired_min: float = max(0.0, cur_min_pct * reach)
	var desired_max: float = max(0.0, cur_max_pct * reach)

	var edge_gap_min_from_desired: float = max(0.0, desired_min - half_new)
	var edge_gap_max_from_desired: float = max(0.0, desired_max - half_new)

	var max_allowed_gap: float = min(MAX_EDGE_GAP, max_edge_gap_physical)
	max_allowed_gap = min(max_allowed_gap, MAX_MAIN_EDGE_GAP_ABS)

	var allowed_min: float = max(edge_gap_min_from_desired, MIN_MAIN_EDGE_GAP_ABS)
	var allowed_max: float = min(edge_gap_max_from_desired, max_allowed_gap)

	var found: bool = false
	var chosen_edge_gap: float = 0.0
	var chosen_seg: int = seg_main
	var attempts: int = 0
	var max_attempts: int = 12

	while not found and attempts < max_attempts:
		half_new = float(chosen_seg) * TILE_SIZE * 0.5
		max_edge_gap_physical = max(0.0, reach - SAFE_MARGIN_X - half_new)

		edge_gap_min_from_desired = max(0.0, desired_min - half_new)
		edge_gap_max_from_desired = max(0.0, desired_max - half_new)

		max_allowed_gap = min(MAX_EDGE_GAP, max_edge_gap_physical)
		max_allowed_gap = min(max_allowed_gap, MAX_MAIN_EDGE_GAP_ABS)

		allowed_min = max(edge_gap_min_from_desired, MIN_MAIN_EDGE_GAP_ABS)
		allowed_max = min(edge_gap_max_from_desired, max_allowed_gap)

		if allowed_max < allowed_min:
			if chosen_seg > MAIN_MIN_SEGMENTS:
				chosen_seg -= 1
				attempts += 1
				continue
			else:
				break

		var candidates: Array[float] = [(allowed_min + allowed_max) * 0.5, allowed_min, allowed_max]

		for c in candidates:
			var dir_x: float = 1.0 if going_right else -1.0
			var tentative_x: float = last_main_pos.x + dir_x * (half_prev + half_new + c)
			var clamped_x: float = clamp(tentative_x, min_center_x, max_center_x)
			var candidate_pos: Vector2 = Vector2(clamped_x, new_y)

			if clamped_x != tentative_x:
				wall_clamp_count += 1
				if wall_clamp_count >= WALL_CLAMP_THRESHOLD:
					going_right = not going_right
					wall_clamp_count = 0
					break
				continue

			if _can_place_platform_at(candidate_pos, chosen_seg):
				found = true
				chosen_edge_gap = c
				break

		if not found:
			if chosen_seg > MAIN_MIN_SEGMENTS:
				chosen_seg -= 1
				attempts += 1
				continue
			else:
				break

	if found:
		var p: Node2D = platform_scene.instantiate()
		platforms_root.add_child(p)

		var dir_x_final: float = 1.0 if going_right else -1.0
		var tentative_x_final: float = last_main_pos.x + dir_x_final * (half_prev + float(chosen_seg) * TILE_SIZE * 0.5 + chosen_edge_gap)
		var clamped_x_final: float = clamp(tentative_x_final, min_center_x, max_center_x)

		var final_pos: Vector2 = Vector2(clamped_x_final, new_y)

		p.global_position = final_pos
		p.scale.x = float(chosen_seg)
		platforms.append(p)

		last_main_segments = chosen_seg
		last_main_pos = final_pos


		_spawn_decoys_around(p.global_position, chosen_seg)
		return

	# fallback
	var fallback_pos: Vector2 = Vector2(clamp(last_main_pos.x, min_center_x, max_center_x), new_y)
	var main_platform: Node2D = _spawn_main_platform_at(fallback_pos, seg_main)
	_spawn_decoys_around(main_platform.global_position, seg_main)

func _spawn_decoys_around(main_pos: Vector2, main_segments: int) -> void:
	var num_decoys: int = rng.randi_range(2, 3)
	if num_decoys <= 0:
		return

	for _i in range(num_decoys):
		var seg: int = rng.randi_range(DECOY_MIN_SEGMENTS, DECOY_MAX_SEGMENTS)
		var side: float = 1.0 if rng.randf() < 0.5 else -1.0
		var extra_offset: float = rng.randf_range(DECOY_OFFSET_X_MIN, DECOY_OFFSET_X_MAX)

		var half_main: float = float(main_segments) * TILE_SIZE * 0.5
		var half_decoy: float = float(seg) * TILE_SIZE * 0.5

		var decoy_center_x: float = main_pos.x + side * (half_main + half_decoy + extra_offset)
		decoy_center_x = clamp(decoy_center_x, min_center_x, max_center_x)

		var offset_y: float = rng.randf_range(-2.0 * PLATFORM_HEIGHT, 2.0 * PLATFORM_HEIGHT)
		var decoy_pos: Vector2 = Vector2(decoy_center_x, main_pos.y + offset_y)

		if not _can_place_platform_at(decoy_pos, seg):
			continue

		var decoy: Node2D = platform_scene.instantiate()
		platforms_root.add_child(decoy)
		decoy.global_position = decoy_pos
		decoy.scale.x = float(seg)
		platforms.append(decoy)

func _update_platforms_around_player() -> void:
	var player_y: float = player.global_position.y

	var remove_below: float = player_y + viewport_height
	for p in platforms.duplicate():
		if p.global_position.y > remove_below:
			platforms.erase(p)
			p.queue_free()

	var upper_limit: float = player_y - viewport_height
	while platforms.size() < MIN_TOTAL_PLATFORMS or last_main_pos.y > upper_limit:
		_spawn_next_step()


--- FILE: D:\YandexDisk\Projects\Runner\Godot\scripts\Platform.gd ---

extends StaticBody2D
# Platform.gd — УЛУЧШЕННАЯ ГЕНЕРАЦИЯ МОНЕТ (как у тебя)

@export var size: Vector2 = Vector2(64, 64)
@export var coin_spawn_chance: float = 0.8
@export var coin_height_offset: float = 80.0

@onready var collision_shape: CollisionShape2D = $CollisionShape2D

var coin_scene: PackedScene
var rng: RandomNumberGenerator = RandomNumberGenerator.new()

func _ready() -> void:
	rng.randomize()
	
	# Платформа на переднем плане (z_index > стены)
	z_index = 0

	coin_scene = preload("res://Coin.tscn")

	if collision_shape != null:
		var rect_shape := RectangleShape2D.new()
		rect_shape.size = size
		collision_shape.shape = rect_shape
		collision_shape.one_way_collision = true
		collision_shape.one_way_collision_margin = 10.0

	# Платформа на слое 1
	set_collision_layer_value(1, true)
	for i in range(2, 33):
		set_collision_layer_value(i, false)

	if coin_scene != null and coin_spawn_chance > 0.0:
		if rng.randf() < coin_spawn_chance:
			await get_tree().create_timer(0.1).timeout
			_spawn_coin_above()

	queue_redraw()

func _spawn_coin_above() -> void:
	if coin_scene == null:
		return

	var coin := coin_scene.instantiate()

	var root = get_tree().current_scene
	if root:
		root.add_child(coin)

		var platform_center := global_position
		var coin_pos := platform_center + Vector2(0.0, -coin_height_offset)
		coin.global_position = coin_pos

func _draw() -> void:
	var rect := Rect2(-size * 0.5, size)
	draw_rect(rect, Color(0.1, 0.9, 0.2, 1.0))


--- FILE: D:\YandexDisk\Projects\Runner\Godot\scripts\Player.gd ---

extends CharacterBody2D
# ============================================================================
# Player.gd — Улучшенная логика смерти: падение на 2 экрана от последней платформы
# ----------------------------------------------------------------------------
# - Смерть наступает, если игрок упал на 2 экрана ниже последней безопасной позиции
# - Резерв: абсолютный предел FALL_LIMIT_Y_ABSOLUTE
# - Защита от ложных срабатываний: условие должно держаться FALL_DEATH_HOLD_SECONDS
# - DEBUG вывод можно отключить
# ============================================================================

@export var GRAVITY: float = 2000.0
@export var MOVE_SPEED: float = 350.0
@export var JUMP_VELOCITY: float = -960.0
@export var DEFAULT_MOVE_DIR: float = 1.0

@export var JUMP_COOLDOWN: float = 0.08
@export var USE_PIXEL_SNAP: bool = true

# Камера / абсолютные параметры
@export var DEATH_SCREENS: float = 2.0  # Количество экранов ниже последней безопасной позиции для смерти
@export var FALL_LIMIT_Y_ABSOLUTE: float = 15000.0

# Сколько секунд условие должно держаться, прежде чем вызвать _die()
@export var FALL_DEATH_HOLD_SECONDS: float = 0.5

# Включить/выключить подробный лог
@export var DEBUG: bool = true

@export_file("*.tscn") var main_menu_scene: String = "res://MainMenu.tscn"

# Отдельная сцена для экрана Game Over.
@export_file("*.tscn") var game_over_scene: String = "res://GameOver.tscn"

# ----------------------------------------------------------------------------
# Ресурсы героев (настраиваются в инспекторе)
# ----------------------------------------------------------------------------
@export var frames_default: SpriteFrames
@export var frames_monster: SpriteFrames
@export var frames_red: SpriteFrames
@export var frames_blue: SpriteFrames
@export var frames_orange: SpriteFrames

var move_dir: float = 0.0
var jump_timer: float = 0.0
var _was_touching_floor: bool = false

# Кастом-аватар
var _custom_tex_up: Texture2D = null
var _custom_tex_down: Texture2D = null
var _using_custom_avatar: bool = false
const CUSTOM_AVATAR_TARGET_SIZE_PX: int = 128

# Таймеры для "удержания" условия смерти
var _fall_death_timer: float = 0.0

# Последняя безопасная позиция Y (где стоял на платформе)
var last_safe_y: float = 0.0

@onready var cam: Camera2D = $Camera2D
@onready var anim: AnimatedSprite2D = $AnimatedSprite2D
@onready var custom_sprite: Sprite2D = $CustomAvatarSprite

func _ready() -> void:
	if DEBUG:
		pass
	# Коллизии: игрок = слой 1, реагируем на платформы (1) и монеты (2)
	set_collision_layer_value(1, true)
	set_collision_mask_value(1, true)
	set_collision_mask_value(2, true)
	for i in range(3, 33):
		set_collision_mask_value(i, false)

	if abs(DEFAULT_MOVE_DIR) < 0.001:
		DEFAULT_MOVE_DIR = 1.0
	move_dir = DEFAULT_MOVE_DIR

	_was_touching_floor = is_on_floor()
	
	# ИНИЦИАЛИЗИРУЕМ ПОСЛЕДНЮЮ БЕЗОПАСНУЮ ПОЗИЦИЮ
	last_safe_y = global_position.y
	if DEBUG:
		pass

	# ----------------------------------------------------------------------------
	# ИНИЦИАЛИЗАЦИЯ МАКСИМАЛЬНОЙ ВЫСОТЫ ДЛЯ CUBEVIEW / GameOver
	# ----------------------------------------------------------------------------
	# В CubeView и GameOver нужно знать, какую максимальную высоту (минимальное Y)
	# достигал игрок за забег. Инициализируем max_height_reached стартовой позицией.
	# Далее это значение уменьшается по мере «подъёма» игрока вверх (Y ↓ в Godot).
	var gs: Node = get_node_or_null("/root/GameState")
	if gs != null:
		GameState.max_height_reached = global_position.y

	if cam:
		cam.make_current()

	_apply_visual_mode()

func _apply_visual_mode() -> void:
	_using_custom_avatar = bool(GameState.get_use_custom_avatar())

	if _using_custom_avatar:
		var ok: bool = _load_custom_avatar_textures()
		if ok:
			if custom_sprite:
				custom_sprite.visible = true
			if anim:
				anim.visible = false
			if DEBUG:
				pass
			return
		else:
			_using_custom_avatar = false
			GameState.set_use_custom_avatar(false)
			if DEBUG:
				pass

	if custom_sprite:
		custom_sprite.visible = false
	if anim:
		anim.visible = true

	var hero_id: String = str(GameState.get_selected_hero_id()).strip_edges()
	if hero_id == "":
		hero_id = "default"

	var target_frames: SpriteFrames = null
	match hero_id:
		"monster": target_frames = frames_monster
		"red":     target_frames = frames_red
		"blue":    target_frames = frames_blue
		"orange":  target_frames = frames_orange
		_:         target_frames = frames_default

	if target_frames:
		anim.sprite_frames = target_frames

	if anim and anim.sprite_frames != null and anim.sprite_frames.has_animation("JUMP"):
		anim.stop()
		anim.animation = "JUMP"
		anim.frame = 0

func _load_custom_avatar_textures() -> bool:
	_custom_tex_up = null
	_custom_tex_down = null

	var up_path: String = str(GameState.get_custom_avatar_up_path()).strip_edges()
	var down_path: String = str(GameState.get_custom_avatar_down_path()).strip_edges()

	if up_path == "":
		up_path = "user://custom_jump_up.png"
	if down_path == "":
		down_path = "user://custom_jump_down.png"

	if not FileAccess.file_exists(up_path) or not FileAccess.file_exists(down_path):
		return false

	var img_up: Image = Image.new()
	if img_up.load(up_path) != OK:
		return false
	var img_down: Image = Image.new()
	if img_down.load(down_path) != OK:
		return false

	if img_up.get_format() != Image.FORMAT_RGBA8:
		img_up.convert(Image.FORMAT_RGBA8)
	if img_down.get_format() != Image.FORMAT_RGBA8:
		img_down.convert(Image.FORMAT_RGBA8)

	var fitted_up: Image = _fit_image_into_square(img_up, CUSTOM_AVATAR_TARGET_SIZE_PX)
	var fitted_down: Image = _fit_image_into_square(img_down, CUSTOM_AVATAR_TARGET_SIZE_PX)

	var up_tex: ImageTexture = ImageTexture.new()
	var down_tex: ImageTexture = ImageTexture.new()
	up_tex.set_image(fitted_up)
	down_tex.set_image(fitted_down)

	_custom_tex_up = up_tex
	_custom_tex_down = down_tex

	if custom_sprite:
		custom_sprite.texture = _custom_tex_up

	return true

func _input(event: InputEvent) -> void:
	if event is InputEventMouseButton and event.pressed:
		if event.button_index == MOUSE_BUTTON_LEFT:
			var center: float = get_viewport_rect().size.x * 0.5
			move_dir = -1.0 if event.position.x < center else 1.0
	elif event is InputEventScreenTouch and event.pressed:
		var center: float = get_viewport_rect().size.x * 0.5
		move_dir = -1.0 if event.position.x < center else 1.0

func _physics_process(delta: float) -> void:
	# ВАЖНО: сначала проверяем флаг конца игры, чтобы после смерти
	# не было бесконечного спама логов от игрока.
	var gs: Node = get_node_or_null("/root/GameState")
	if gs != null and GameState.is_game_over:
		return

	velocity.y += GRAVITY * delta

	var key_dir: float = 0.0
	if Input.is_action_pressed("move_left"):
		key_dir -= 1.0
	if Input.is_action_pressed("move_right"):
		key_dir += 1.0
	if key_dir != 0.0:
		move_dir = key_dir

	velocity.x = move_dir * MOVE_SPEED
	move_and_slide()

	if USE_PIXEL_SNAP:
		global_position = global_position.round()

	# ----------------------------------------------------------------------------
	# ОБНОВЛЕНИЕ МАКСИМАЛЬНОЙ ВЫСОТЫ ДЛЯ CUBEVIEW / GameOver
	# ----------------------------------------------------------------------------
	# В Godot Y растёт вниз. МЕНЬШЕ Y = выше на экране.
	# Сохраняем минимальное Y за забег (максимальная достигнутая высота).
	# gs уже получен выше.
	if gs != null and not GameState.is_game_over:
		if GameState.max_height_reached == 0.0:
			GameState.max_height_reached = global_position.y
		elif global_position.y < GameState.max_height_reached:
			GameState.max_height_reached = global_position.y

	jump_timer = max(0.0, jump_timer - delta)

	var touching_floor_now: bool = _check_floor_collision()
	
	# ОБНОВЛЯЕМ ПОСЛЕДНЮЮ БЕЗОПАСНУЮ ПОЗИЦИЮ ПРИ КАСАНИИ ПЛАТФОРМЫ
	if touching_floor_now:
		last_safe_y = global_position.y
	
	if touching_floor_now and not _was_touching_floor and jump_timer <= 0.0:
		velocity.y = JUMP_VELOCITY
		jump_timer = JUMP_COOLDOWN

	_was_touching_floor = touching_floor_now

	_update_jump_visual()

	# Проверка смерти с удержанием порога (debounce)
	_process_fall_death(delta)

func _update_jump_visual() -> void:
	var going_up: bool = (velocity.y < 0.0)

	if anim:
		anim.flip_h = (move_dir < 0.0)
	if custom_sprite:
		custom_sprite.flip_h = (move_dir < 0.0)

	if _using_custom_avatar:
		if custom_sprite and _custom_tex_up != null and _custom_tex_down != null:
			custom_sprite.texture = _custom_tex_up if going_up else _custom_tex_down
		return

	if anim == null or anim.sprite_frames == null:
		return
	if not anim.sprite_frames.has_animation("JUMP"):
		return

	anim.stop()
	anim.animation = "JUMP"
	anim.frame = 0 if going_up else 1

# ----------------------------------------------------------------------------
# Обработка смерти с удержанием порога (debounce)
# ----------------------------------------------------------------------------
func _process_fall_death(delta: float) -> void:
	if Engine.has_singleton("GameState") and GameState.is_game_over:
		return

	if cam == null:
		# Если камеры нет — используем только абсолютный лимит
		if global_position.y > FALL_LIMIT_Y_ABSOLUTE:
			_fall_death_timer += delta
		else:
			_fall_death_timer = 0.0

		if _fall_death_timer >= FALL_DEATH_HOLD_SECONDS:
			_die()
		return

	# Вычисляем видимую высоту экрана с учётом зума
	var viewport_size: Vector2 = get_viewport().get_visible_rect().size
	var viewport_height: float = max(1.0, viewport_size.y)

	var zoom_y: float = float(cam.zoom.y)
	var visible_height: float = viewport_height * zoom_y

	# 🔴 ИЗМЕНЕНИЕ: Используем last_safe_y вместо позиции камеры
	# Смерть наступает, если игрок упал на 2 экрана ниже последней безопасной позиции
	var death_y: float = last_safe_y + visible_height * DEATH_SCREENS

	# Лог для отладки
	if DEBUG:
		pass

	# Условие: игрок ниже death_y (2 экрана от последней безопасной позиции)
	var fall_from_safe_condition: bool = (global_position.y > death_y)
	
	# Условие абсолютного лимита
	var absolute_condition: bool = (global_position.y > FALL_LIMIT_Y_ABSOLUTE)

	# ----------------------------------------------------------------------------
	# ВРЕМЕННЫЙ РЕЖИМ: МГНОВЕННАЯ СМЕРТЬ ДЛЯ ОТЛАДКИ GAME OVER → CUBEVIEW
	# ----------------------------------------------------------------------------
	# Сейчас нам нужно гарантированно и быстро попадать в Game Over,
	# чтобы отладить связку:
	#   смерть игрока -> GameState.is_game_over -> переход в меню/экран
	#   -> последующий вход в CubeView и проверка высотного гейта.
	#
	# Поэтому мы ВРЕМЕННО отключаем "debounce" (удержание условия в течение
	# FALL_DEATH_HOLD_SECONDS) и вызываем _die() сразу при выполнении
	# одного из условий смерти.
	#
	# Архитектурно:
	# - Вся логика смерти по‑прежнему сосредоточена в _process_fall_death().
	# - Поле FALL_DEATH_HOLD_SECONDS и таймер _fall_death_timer остаются
	#   и могут быть легко возвращены в игру — блок кода с debounce ниже
	#   оставлен как готовый шаблон.
	# - Остальной геймплей и стена не затронуты.
	#
	# Как вернуть debounce позже:
	# 1. Закомментировать этот "мгновенный" блок.
	# 2. Разкомментировать/включить блок ниже "DEBOUNCE‑ВЕРСИЯ".
	#
	# Это даёт:
	# - Сейчас: предельно предсказуемую, мгновенную смерть для отладки.
	# - В будущем: возможность мягко фильтровать ложные срабатывания
	#   (например, при дрожании камеры или резких ускорениях), просто
	#   вернув старую логику без переписывания функции.
	if fall_from_safe_condition or absolute_condition:
		_die()
		return

	# ----------------------------------------------------------------------------
	# DEBOUNCE‑ВЕРСИЯ (ИЗНАЧАЛЬНАЯ ЛОГИКА С УДЕРЖАНИЕМ УСЛОВИЯ)
	# ----------------------------------------------------------------------------
	# Оставлена как готовый шаблон на будущее — сейчас НЕ используется,
	# потому что выше стоит мгновенный возврат.
	# ----------------------------------------------------------------------------

	# Прежний вариант:
	# # Если хоть одно условие истинно — увеличиваем таймер удержания
	# if fall_from_safe_condition or absolute_condition:
	# 	_fall_death_timer += delta
	# else:
	# 	# Сбрасываем таймер при возврате в безопасную зону
	# 	_fall_death_timer = 0.0
	#
	# # Если условие держалось достаточно долго — умираем
	# if _fall_death_timer >= FALL_DEATH_HOLD_SECONDS:

# ----------------------------------------------------------------------------
# Смерть / смена сцены
# ----------------------------------------------------------------------------
func _die() -> void:
	if Engine.has_singleton("GameState"):
		if GameState.is_game_over:
			return
		GameState.is_game_over = true

	# В редакторе — перезагрузим текущую сцену для удобства,
	# чтобы не прыгать по полноэкранному Game Over при тестах.
	if Engine.is_editor_hint():
		get_tree().reload_current_scene()
		return

	# ----------------------------------------------------------------------------
	# ФИКСАЦИЯ ДАННЫХ ПЕРЕД ПЕРЕХОДОМ НА GameOver
	# ----------------------------------------------------------------------------
	# Player НЕ обновляет UI. Player ТОЛЬКО фиксирует данные в GameState.
	# GameOver читает last_run_score и last_run_max_height — записываем ДО смены сцены.
	var gs_die: Node = get_node_or_null("/root/GameState")
	if gs_die != null:
		GameState.last_run_score = GameState.score
		GameState.last_run_max_height = GameState.max_height_reached
		GameState.has_finished_run = true

	# Регистрируем результат забега ОДИН раз, до перехода на GameOver.
	GameState.register_run_finished()
	
	# ----------------------------------------------------------------------------
	# Переход на экран Game Over
	# ----------------------------------------------------------------------------
	# ВАЖНО:
	# - Мы больше НЕ перезапускаем Level.tscn напрямую из Player.
	# - Мы НЕ уходим сразу в главное меню.
	# - Вместо этого используем отдельную UI-сцену GameOver.tscn, которая:
	#   * читает данные из GameState (очки, высоту и т.д.),
	#   * даёт кнопки: "View Cube", "Restart Run", "Main Menu".
	# - Логика стены и сегментов НЕ ЗАТРАГИВАЕТСЯ, т.к. они существуют
	#   только в Level / CubeView, а Game Over — чистый UI.
	# ----------------------------------------------------------------------------
	var target_scene: String = game_over_scene
	if target_scene == "" or target_scene == null:
		# Фоллбек: если по какой-то причине путь к GameOver не задан,
		# уходим в главное меню или перезагружаем текущую сцену.
		target_scene = main_menu_scene
	
	if target_scene != "" and target_scene != null:
		var err: int = get_tree().change_scene_to_file(target_scene)
		if err != OK:
			push_error("Player.gd: cannot load game over or main menu: " + target_scene)
			get_tree().reload_current_scene()
	else:
		get_tree().reload_current_scene()

func _check_floor_collision() -> bool:
	var count: int = get_slide_collision_count()
	if count == 0:
		return is_on_floor()
	for i in range(count):
		var c = get_slide_collision(i)
		if c and c.get_normal().y < -0.7:
			return true
	return false

func _fit_image_into_square(src: Image, target_size: int) -> Image:
	var src_w: int = src.get_width()
	var src_h: int = src.get_height()

	if src_w <= 0 or src_h <= 0:
		var empty: Image = Image.create(target_size, target_size, false, Image.FORMAT_RGBA8)
		empty.fill(Color(0,0,0,0))
		return empty

	var dst: Image = Image.create(target_size, target_size, false, Image.FORMAT_RGBA8)
	dst.fill(Color(0, 0, 0, 0))

	var resized: Image = src.duplicate()
	if resized.get_format() != Image.FORMAT_RGBA8:
		resized.convert(Image.FORMAT_RGBA8)

	var scale: float = min(float(target_size) / float(src_w), float(target_size) / float(src_h))
	var new_w: int = max(1, int(round(float(src_w) * scale)))
	var new_h: int = max(1, int(round(float(src_h) * scale)))

	resized.resize(new_w, new_h, Image.INTERPOLATE_LANCZOS)

	var x: int = int((target_size - new_w) / 2)
	var y: int = int((target_size - new_h) / 2)

	dst.blit_rect(resized, Rect2i(0, 0, new_w, new_h), Vector2i(x, y))
	return dst


--- FILE: D:\YandexDisk\Projects\Runner\Godot\wall\data\WallData.gd ---

extends Node
class_name WallData
# ============================================================================
# WallData.gd
# Хранилище данных стены (локально, без онлайна)
# ============================================================================
# - хранит сегменты с полными данными (faces, images, links, prices, height)
# - знает кто купил каждую сторону
# - позже легко подключается к JSON / серверу
# ============================================================================

# segment_id -> {
#   "height": float,           # Высота сегмента (Y координата)
#   "price": int,              # Цена покупки (coin)
#   "faces": {                 # Данные для каждой из 6 сторон
#     "front": { "owner": "", "image_id": "", "image_path": "", "link": "" },
#     "back": { ... },
#     "left": { ... },
#     "right": { ... },
#     "top": { ... },
#     "bottom": { ... }
#   },
#   "first_owner": "",         # Первый владелец (для истории)
#   "purchase_date": int       # Unix timestamp покупки
# }
var segments: Dictionary = {}

# Базовые цены (можно вынести в GameState позже)
const BASE_PRICE_FREE: int = 10    # Цена для free-сегментов (нижняя часть)
const BASE_PRICE_PAID: int = 50    # Цена для paid-сегментов

# ---------------------------------------------------------------------------

func has_segment(id: String) -> bool:
	return segments.has(id)

# ---------------------------------------------------------------------------

func get_segment(id: String) -> Dictionary:
	if not segments.has(id):
		# Вычисляем высоту из segment_id (формат: "x_y")
		var coords: Array = id.split("_")
		var seg_y: float = 0.0
		if coords.size() >= 2:
			seg_y = float(coords[1]) * 48.0  # SEGMENT_SIZE = 48
		
		# Определяем тип сегмента (free или paid) по высоте
		var is_free: bool = seg_y >= 0  # Free-сегменты в нижней части (y >= 0)
		var price: int = BASE_PRICE_FREE if is_free else BASE_PRICE_PAID
		
		segments[id] = {
			"height": seg_y,
			"price": price,
			"faces": {
				"front": { "owner": "", "image_id": "", "image_path": "", "link": "" },
				"back": { "owner": "", "image_id": "", "image_path": "", "link": "" },
				"left": { "owner": "", "image_id": "", "image_path": "", "link": "" },
				"right": { "owner": "", "image_id": "", "image_path": "", "link": "" },
				"top": { "owner": "", "image_id": "", "image_path": "", "link": "" },
				"bottom": { "owner": "", "image_id": "", "image_path": "", "link": "" }
			},
			"first_owner": "",
			"purchase_date": 0
		}
	return segments[id]

# ---------------------------------------------------------------------------

func get_segment_height(segment_id: String) -> float:
	var seg := get_segment(segment_id)
	return float(seg.get("height", 0.0))

# ---------------------------------------------------------------------------

func get_segment_price(segment_id: String) -> int:
	var seg := get_segment(segment_id)
	return int(seg.get("price", BASE_PRICE_PAID))

# ---------------------------------------------------------------------------

func buy_side(segment_id: String, side: String, buyer_uid: String, coin_cost: int) -> bool:
	# Проверка высоты (обязательно по ТЗ)
	var seg := get_segment(segment_id)
	var seg_height: float = float(seg.get("height", 0.0))
	
	# Проверяем max_height игрока (в Godot Y меньше = выше)
	if Engine.has_singleton("GameState"):
		var max_height: float = float(GameState.max_height_reached)
		# segment_height должен быть >= max_height (сегмент ниже или на уровне достигнутой высоты)
		if seg_height < max_height:
			return false  # Сегмент выше достигнутой высоты
	
	# Проверка достаточности монет
	if Engine.has_singleton("GameState"):
		if GameState.score < coin_cost:
			return false
	
	var faces: Dictionary = seg.get("faces", {})
	if not faces.has(side):
		return false
	
	var face_data: Dictionary = faces[side]
	
	# Уже куплено
	if str(face_data.get("owner", "")) != "":
		return false
	
	# Списываем монеты
	if Engine.has_singleton("GameState"):
		GameState.score -= coin_cost
		GameState.save_scores()
	
	# Покупаем
	face_data["owner"] = buyer_uid
	face_data["purchase_date"] = Time.get_unix_time_from_system()
	
	# Сохраняем первого владельца
	if seg.get("first_owner", "") == "":
		seg["first_owner"] = buyer_uid
		seg["purchase_date"] = Time.get_unix_time_from_system()
	
	faces[side] = face_data
	seg["faces"] = faces
	segments[segment_id] = seg
	
	return true

# ---------------------------------------------------------------------------

func get_face_data(segment_id: String, side: String) -> Dictionary:
	var seg := get_segment(segment_id)
	var faces: Dictionary = seg.get("faces", {})
	if faces.has(side):
		return faces[side].duplicate()
	return {}

# ---------------------------------------------------------------------------

func set_face_image(segment_id: String, side: String, image_path: String) -> bool:
	var seg := get_segment(segment_id)
	var faces: Dictionary = seg.get("faces", {})
	if not faces.has(side):
		return false
	
	var face_data: Dictionary = faces[side]
	face_data["image_path"] = image_path
	faces[side] = face_data
	seg["faces"] = faces
	segments[segment_id] = seg
	return true

# ---------------------------------------------------------------------------

func set_face_link(segment_id: String, side: String, link: String) -> bool:
	# Проверка живой ссылки (по ТЗ)
	if link.strip_edges() == "":
		return false
	
	# TODO: Проверка доступности ссылки (HTTP request)
	# Пока просто сохраняем
	
	var seg := get_segment(segment_id)
	var faces: Dictionary = seg.get("faces", {})
	if not faces.has(side):
		return false
	
	var face_data: Dictionary = faces[side]
	face_data["link"] = link.strip_edges()
	faces[side] = face_data
	seg["faces"] = faces
	segments[segment_id] = seg
	return true

# ---------------------------------------------------------------------------

func reset() -> void:
	segments.clear()


--- FILE: D:\YandexDisk\Projects\Runner\Godot\wall\segment\WallSegment.gd ---

extends Node2D
# ============================================================================
# WallSegment.gd
# Один сегмент стены (48x48)
# Визуал: Sprite2D
# Взаимодействие: Area2D
# Минимальная анимация: мягкое покачивание
# ============================================================================

@export var segment_id: String = ""

# Режим стены: статика / "живая" стена
const WALL_MODE_STATIC: int = 0
const WALL_MODE_LIVING: int = 1
@export var wall_mode: int = WALL_MODE_LIVING

# Режим сегмента: хаотичный / синхронный показ
const SEGMENT_MODE_RANDOM: int = 0
const SEGMENT_MODE_SYNC_SHOW: int = 1
var segment_mode: int = SEGMENT_MODE_RANDOM

@onready var area: Area2D = $Area2D
@onready var sprite: Sprite2D = $Sprite2D
@onready var visibility_notifier: VisibleOnScreenNotifier2D = $VisibleOnScreenNotifier2D

var wall_data: WallData = null
var side_id: String = "front"  # Сторона мега-куба

# Параметры дыхания: каждый сегмент двигается рандомно
var _time_accum: float = 0.0
var _breath_amplitude: float = 1.2
var _breath_speed: float = PI * 0.4
var _breath_speed_factor: float = 1.0
var _breath_phase: float = 0.0

# Микро-вариация яркости для визуального разнообразия
var _brightness_variation: float = 1.0

# Независимый таймер цвета (для лёгкой дрожи яркости)
var _color_time: float = 0.0
var _color_speed: float = 0.0
var _color_phase: float = 0.0

# Базовая локальная позиция по Y (для дыхания)
var _base_y: float = 0.0

# Базовая Y позиция узла сегмента (для централизованного дыхания в wall.gd)
var base_position_y: float = 0.0

# Текущий базовый цвет сегмента
var _base_color: Color = Color(1, 1, 1, 1)

# Параметры вращения (асинхронно, с паузами)
var _rot_time: float = 0.0
var _rot_amp: float = 0.0
var _rot_speed: float = 1.0
var _rot_phase: float = 0.0
var _rot_timer: float = 0.0
var _rot_active: bool = false

# Параметры синхронного показа (архитектура на будущее)
var _sync_show_timer: float = 0.0
var _sync_show_side: String = ""
@export var sync_show_interval: float = 60.0

# Флаг, чтобы один раз вывести в консоль, что анимация активна
var _animation_logged: bool = false


func start_sync_show(side: String, duration: float) -> void:
	# В будущем wall.gd или другой менеджер может вызывать это
	# для синхронного показа выбранной стороны на группе сегментов.
	segment_mode = SEGMENT_MODE_SYNC_SHOW
	_sync_show_side = side
	_sync_show_timer = max(0.0, duration)
	side_id = side


# ---------------------------------------------------------------------------
# ОБЯЗАТЕЛЬНЫЙ МЕТОД — его вызывает wall.gd
# ---------------------------------------------------------------------------

func setup(id: String, side: String, data: WallData, allow_purchases_flag: bool = false) -> void:
	segment_id = id
	side_id = side
	wall_data = data
	base_position_y = position.y
	
	# Отключаем/включаем покупки в зависимости от флага
	if area:
		area.input_pickable = allow_purchases_flag
		area.monitoring = allow_purchases_flag
	
	# Генерируем микро-вариацию яркости (±5-10%)
	_brightness_variation = 0.95 + randf() * 0.1  # От 0.95 до 1.05

	# Рандомные параметры "дыхания" — каждый сегмент двигается по-своему
	_breath_speed_factor = randf_range(0.6, 1.4)
	_breath_phase = randf() * TAU

	# Асинхронные параметры цвета (очень медленная дрожь яркости)
	_color_speed = randf_range(0.15, 0.4)
	_color_phase = randf() * TAU

	_rot_amp = deg_to_rad(randf_range(1.0, 4.0))   # небольшая амплитуда вращения
	_rot_speed = randf_range(0.5, 1.5)
	_rot_phase = randf() * TAU
	_rot_timer = randf_range(0.5, 2.5)
	_rot_active = randf() < 0.7  # иногда кубы могут не вращаться долго
	
	_update_visual_state()
	_reset_geometry()


var _change_timer: float = 0.0
var _change_interval: float = 0.0


func _ready() -> void:
	# _process только для видимых сегментов (оптимизация)
	if visibility_notifier:
		if not visibility_notifier.screen_entered.is_connected(_on_screen_entered):
			visibility_notifier.screen_entered.connect(_on_screen_entered)
		if not visibility_notifier.screen_exited.is_connected(_on_screen_exited):
			visibility_notifier.screen_exited.connect(_on_screen_exited)
		set_process(visibility_notifier.is_on_screen())
	else:
		set_process(true)

	_change_timer = 0.0
	_change_interval = randf_range(30.0, 90.0)

	# Подключаем клики
	if area and not area.input_event.is_connected(_on_area_input):
		area.input_event.connect(_on_area_input)

	# Инициализируем микро-вариацию яркости, если не была установлена в setup()
	if _brightness_variation == 1.0:
		_brightness_variation = 0.95 + randf() * 0.1  # От 0.95 до 1.05

	# Если параметры дыхания / вращения / цвета ещё не заданы из setup()
	if _breath_speed_factor == 1.0 and _breath_phase == 0.0:
		_breath_speed_factor = randf_range(0.6, 1.4)
		_breath_phase = randf() * TAU
	if _color_speed == 0.0:
		_color_speed = randf_range(0.15, 0.4)
		_color_phase = randf() * TAU
	if _rot_amp == 0.0:
		_rot_amp = deg_to_rad(randf_range(1.0, 4.0))
		_rot_speed = randf_range(0.5, 1.5)
		_rot_phase = randf() * TAU
		_rot_timer = randf_range(0.5, 2.5)
		_rot_active = randf() < 0.7

	_update_visual_state()
	_reset_geometry()

	# Случайный старт фазы для разнообразия
	_time_accum = randf() * TAU


func _on_screen_entered() -> void:
	set_process(true)


func _on_screen_exited() -> void:
	set_process(false)
	if sprite:
		sprite.position = Vector2.ZERO


func _process(delta: float) -> void:
	if wall_mode == WALL_MODE_STATIC:
		return

	# Проверка настройки: если выключено — стена статична
	if not GameState.wall_breathing_enabled:
		if sprite:
			sprite.position = Vector2.ZERO
		return

	# Дыхание каждый кадр — каждый сегмент двигается рандомно (дыхание мира)
	_update_minimal_animation(delta)

	_change_timer += delta
	if _change_interval <= 0.0:
		_change_interval = randf_range(30.0, 90.0)

	if _change_timer >= _change_interval:
		_change_timer = 0.0
		_change_interval = randf_range(30.0, 90.0)
		change_side_randomly()


func change_side_randomly() -> void:
	# Лёгкая смена оттенка для видимого "мигания" без тяжёлых вычислений
	if sprite == null:
		return
	# Немного меняем коэффициент яркости и пересчитываем цвет
	_brightness_variation = lerp(0.8, 1.2, randf())
	_update_visual_state()


func _on_area_input(
	viewport: Viewport,
	event: InputEvent,
	shape_idx: int
) -> void:
	if event is InputEventMouseButton and event.pressed:
		_try_buy()


func _try_buy() -> void:
	if wall_data == null:
		push_warning("WallSegment: wall_data == null")
		return

	if not Engine.has_singleton("GameState"):
		push_warning("GameState singleton not found")
		return

	var buyer_uid: String = GameState.player_uid
	var ok: bool = wall_data.buy_side(segment_id, buyer_uid)
	_update_visual_state()


func _update_visual_state() -> void:
	if sprite == null:
		return

	# Базовый бирюзовый цвет по стороне мега-куба
	var base_color: Color = _get_side_color()

	# Микро-вариация яркости (фиксированная для сегмента, НЕ по времени)
	base_color.r *= _brightness_variation
	base_color.g *= _brightness_variation
	base_color.b *= _brightness_variation

	# Если сегмент куплен, слегка подмешиваем зелёный (для будущего UI)
	if wall_data != null:
		var seg := wall_data.get_segment(segment_id)
		if seg != null:
			var owner := str(seg.get("owner", ""))
			if owner != "":
				var owned_color := Color(0.1, 0.8, 0.2)
				base_color = base_color.lerp(owned_color, 0.3)

	_base_color = base_color
	# Немедленно применяем цвет (дальше он будет чуть "дрожать" по яркости)
	sprite.modulate = _base_color


func get_base_position_y() -> float:
	return base_position_y


func _get_side_color() -> Color:
	# ВРЕМЕННАЯ ВИЗУАЛИЗАЦИЯ: разные оттенки бирюзового для каждой стороны
	match side_id:
		"front":
			return Color(0.0, 0.8, 0.7)  # Яркий бирюзовый
		"back":
			return Color(0.0, 0.5, 0.5)  # Тёмно-бирюзовый
		"left":
			return Color(0.2, 0.7, 0.6)  # Зелёно-бирюзовый
		"right":
			return Color(0.1, 0.6, 0.8)  # Голубовато-бирюзовый
		"top":
			return Color(0.3, 0.9, 0.8)  # Светло-бирюзовый
		"bottom":
			return Color(0.0, 0.4, 0.6)  # Холодный сине-бирюзовый
		_:
			return Color(0.0, 0.8, 0.7)  # По умолчанию яркий бирюзовый


# ---------------------------------------------------------------------------
# Геометрия и минимальная анимация
# ---------------------------------------------------------------------------

func _reset_geometry() -> void:
	# КРИТИЧНО: идеальный квадрат 48×48, стена к стене
	# Запрещено: scale ≠ Vector2.ONE, rotation ≠ 0, диагональные смещения
	if sprite == null:
		return

	# Базовая локальная позиция для "дыхания"
	sprite.position = Vector2.ZERO
	_base_y = sprite.position.y
	sprite.scale = Vector2.ONE
	sprite.rotation = 0.0


func _update_minimal_animation(delta: float) -> void:
	# Каждый сегмент двигается рандомно — дыхание мира
	if sprite == null:
		return

	_time_accum += delta
	if _time_accum >= TAU:
		_time_accum = fmod(_time_accum, TAU)

	var phase: float = _time_accum * _breath_speed * _breath_speed_factor + _breath_phase
	var amp: float = _breath_amplitude

	var offset_y: float = sin(phase) * amp
	var offset_x: float = cos(phase) * (amp * 0.5)
	sprite.position = Vector2(offset_x, _base_y + offset_y)


--- FILE: D:\YandexDisk\Projects\Runner\Godot\wall\segment\WallSegment.tscn ---

[gd_scene load_steps=3 format=3 uid="uid://ddaj86ldrt5dv"]

[ext_resource type="Script" uid="uid://vefl2li33f3i" path="res://wall/segment/WallSegment.gd" id="1_6wo4f"]
[ext_resource type="Texture2D" uid="uid://ctja12icu7s5l" path="res://wall/textures/wall_segment.png" id="2_16rbj"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_6wo4f"]
size = Vector2(48, 48)

[node name="WallSegment" type="Node2D"]
script = ExtResource("1_6wo4f")

[node name="Sprite2D" type="Sprite2D" parent="."]
z_index = -10
texture = ExtResource("2_16rbj")

[node name="Area2D" type="Area2D" parent="."]

[node name="CollisionShape2D" type="CollisionShape2D" parent="Area2D"]
shape = SubResource("RectangleShape2D_6wo4f")

[node name="VisibleOnScreenNotifier2D" type="VisibleOnScreenNotifier2D" parent="."]
rect = Rect2(-24, -24, 48, 48)


--- FILE: D:\YandexDisk\Projects\Runner\Godot\wall\wall.gd ---

extends Node2D
# ============================================================================
# wall.gd
# Оптимизированная архитектура стены на основе MultiMesh
# ============================================================================
# - Использует WallRenderer (MultiMeshInstance2D) вместо тысяч нод
# - Данные хранятся в WallData
# - Клики обрабатываются по координатам (без Area2D на каждый сегмент)
# ============================================================================
# Проверено: Godot 4.x
# ============================================================================

# ЗАФИКСИРОВАННЫЕ ПАРАМЕТРЫ
const SEGMENT_SIZE: int = 48
const WORLD_SCREENS: int = 20
const VIEWPORT_WIDTH: int = 1152
const SEGMENTS_PER_SIDE: int = 720  # Виртуальная сторона мега-куба

# Интервал обновления и минимальный сдвиг камеры (оптимизировано для производительности)
const UPDATE_INTERVAL: float = 0.8  # Увеличено с 0.4 для уменьшения частоты апдейтов
const UPDATE_DISTANCE_THRESHOLD: float = 400.0  # Увеличено с 256.0 для более редких обновлений

# Размеры виртуальной стены в пикселях
const VIRTUAL_WALL_SIZE: int = SEGMENTS_PER_SIDE * SEGMENT_SIZE  # 34560 px

# Размер видимой области (в сегментах) с запасом
const VISIBLE_MARGIN: int = 2  # Дополнительные сегменты за пределами экрана

# Сторона мега-куба (для визуализации и отладки)
# Возможные значения: "front" | "back" | "left" | "right" | "top" | "bottom"
var side_id: String = "front"

# Флаг разрешения покупок сегментов (только для CubeView, не для Level)
var allow_purchases: bool = false

# Новый рендерер на основе MultiMesh
var wall_renderer: WallRenderer = null

var wall_data: WallData

# Для отладочного вывода (чтобы не спамить каждый кадр)
var _last_debug_bounds: Dictionary = {}
var _debug_print_cooldown: float = 0.0
const DEBUG_PRINT_INTERVAL: float = 1.0  # Выводить раз в секунду

var _update_timer: float = 0.0
var _last_camera_position: Vector2 = Vector2.INF
var _camera_ref: Camera2D = null
var update_counter: int = 0
var _debug_update_timer: float = 0.0


func _ready() -> void:
	# Стена на заднем плане
	z_index = -10
	
	_camera_ref = get_viewport().get_camera_2d()
	if _camera_ref:
		_last_camera_position = _camera_ref.global_position

	# Локальное хранилище данных стены (без онлайна).
	wall_data = WallData.new()
	add_child(wall_data)

	# Создаём оптимизированный рендерер
	wall_renderer = WallRenderer.new()
	add_child(wall_renderer)
	wall_renderer.setup(wall_data, side_id, allow_purchases)

	call_deferred("_update_visible_segments")


func _process(delta: float) -> void:
	if GameState.disable_wall:
		clear_wall()
		return

	_update_timer += delta
	_debug_update_timer += delta

	var camera := _camera_ref
	if camera == null:
		camera = get_viewport().get_camera_2d()
		_camera_ref = camera
		if camera == null:
			return

	var need_update: bool = false

	if _update_timer >= UPDATE_INTERVAL:
		need_update = true

	if camera:
		var cam_pos: Vector2 = camera.global_position
		if _last_camera_position == Vector2.INF:
			_last_camera_position = cam_pos
		else:
			var dist: float = cam_pos.distance_to(_last_camera_position)
			if dist >= UPDATE_DISTANCE_THRESHOLD:
				need_update = true
				_last_camera_position = cam_pos

	if not need_update:
		return

	_update_timer = 0.0
	update_counter += 1
	_update_visible_segments()

	if _debug_update_timer >= 2.0:
		update_counter = 0
		_debug_update_timer = 0.0


func _update_visible_segments() -> void:
	if wall_renderer == null:
		return
	
	# Получаем позицию камеры
	var camera_pos: Vector2 = Vector2.ZERO
	var camera: Camera2D = get_viewport().get_camera_2d()
	if camera:
		camera_pos = camera.global_position
	else:
		# Fallback: пытаемся найти через Player
		var player: Node = get_tree().get_first_node_in_group("player")
		if player == null:
			# Ищем Player в Level
			var level: Node = get_tree().get_first_node_in_group("level")
			if level == null:
				level = get_parent()
			if level:
				player = level.get_node_or_null("Player")
		
		if player:
			camera = player.get_node_or_null("Camera2D")
			if camera:
				camera_pos = camera.global_position
			else:
				# Используем позицию игрока как приближение
				camera_pos = player.global_position

	# Вычисляем видимую область в мировых координатах
	var viewport_size: Vector2 = get_viewport().get_visible_rect().size
	var viewport_half_width: float = viewport_size.x * 0.5
	var viewport_half_height: float = viewport_size.y * 0.5

	# Границы видимой области в сегментах
	var min_x_seg: int = int(floor((camera_pos.x - viewport_half_width - VISIBLE_MARGIN * SEGMENT_SIZE) / SEGMENT_SIZE))
	var max_x_seg: int = int(ceil((camera_pos.x + viewport_half_width + VISIBLE_MARGIN * SEGMENT_SIZE) / SEGMENT_SIZE))
	var min_y_seg: int = int(floor((camera_pos.y - viewport_half_height - VISIBLE_MARGIN * SEGMENT_SIZE) / SEGMENT_SIZE))
	var max_y_seg: int = int(ceil((camera_pos.y + viewport_half_height + VISIBLE_MARGIN * SEGMENT_SIZE) / SEGMENT_SIZE))

	# Ограничиваем виртуальными границами стены
	min_x_seg = max(min_x_seg, -SEGMENTS_PER_SIDE / 2)
	max_x_seg = min(max_x_seg, SEGMENTS_PER_SIDE / 2)
	min_y_seg = max(min_y_seg, -SEGMENTS_PER_SIDE / 2)
	max_y_seg = min(max_y_seg, SEGMENTS_PER_SIDE / 2)

	# Обновляем рендерер (вместо создания/удаления нод)
	wall_renderer.update_visible_area(min_x_seg, max_x_seg, min_y_seg, max_y_seg)

	# Отладочный вывод (с кулдауном, чтобы не спамить)
	if _debug_print_cooldown <= 0.0:
		var current_bounds := {
			"min_x": min_x_seg,
			"max_x": max_x_seg,
			"min_y": min_y_seg,
			"max_y": max_y_seg
		}
		
		# Выводим только если границы изменились или это первый запуск
		if _last_debug_bounds != current_bounds or _last_debug_bounds.is_empty():
			_print_debug_info(min_x_seg, max_x_seg, min_y_seg, max_y_seg)
			_last_debug_bounds = current_bounds
			_debug_print_cooldown = DEBUG_PRINT_INTERVAL


func clear_wall() -> void:
	# Очищаем рендерер
	if wall_renderer:
		wall_renderer.update_visible_area(0, 0, 0, 0)
	
	# Очищаем старые ноды (если остались)
	for child in get_children():
		if child is WallData or child is WallRenderer:
			continue
		child.queue_free()


func _print_debug_info(min_x: int, max_x: int, min_y: int, max_y: int) -> void:
	# Отладочный вывод информации о стене
	var width: int = max_x - min_x + 1
	var height: int = max_y - min_y + 1
	var segment_count: int = width * height
	# print("Wall: visible segments: %d (%d x %d)" % [segment_count, width, height])

# Обработка клика по координатам (для CubeView)
func handle_click(global_pos: Vector2) -> Dictionary:
	if wall_renderer == null:
		return {}
	return wall_renderer.handle_click(global_pos)

# Обновление конкретного сегмента после покупки
func update_segment_visual(segment_id: String) -> void:
	if wall_renderer:
		wall_renderer.update_segment(segment_id)


--- FILE: D:\YandexDisk\Projects\Runner\Godot\wall\wall.tscn ---

[gd_scene load_steps=2 format=3 uid="uid://dpol13adfo7g3"]

[ext_resource type="Script" uid="uid://bhoujd3rj3ox8" path="res://wall/wall.gd" id="1_sef87"]

[node name="Wall" type="Node2D"]
script = ExtResource("1_sef87")


--- FILE: D:\YandexDisk\Projects\Runner\Godot\wall\WallRenderer.gd ---

extends Node2D
class_name WallRenderer
# ============================================================================
# WallRenderer.gd
# Оптимизированный рендерер стены на основе MultiMeshInstance2D
# ============================================================================
# Вместо тысяч нод использует один MultiMesh для батч-отрисовки
# Данные берутся из WallData, клики обрабатываются по координатам
# ============================================================================

const SEGMENT_SIZE: int = 48
const SEGMENTS_PER_SIDE: int = 720

@onready var multimesh_instance: MultiMeshInstance2D = $MultiMeshInstance2D

var wall_data: WallData = null
var side_id: String = "front"
var allow_purchases: bool = false

# Видимая область (в сегментах)
var visible_min_x: int = 0
var visible_max_x: int = 0
var visible_min_y: int = 0
var visible_max_y: int = 0

# Пул трансформ для переиспользования
var _transforms: Array[Transform2D] = []
var _segment_ids: Array[String] = []
var _multimesh: MultiMesh = null

# Параметры дыхания для каждого сегмента (независимые)
var _breathing_params: Array[Dictionary] = []  # [{phase, speed_factor, amplitude_x, amplitude_y}, ...]
var _breathing_time: float = 0.0
const BASE_BREATHING_AMPLITUDE: float = 1.2
const BASE_BREATHING_SPEED: float = PI * 0.4

# Смена сторон сегментов (каждый сегмент меняет сторону независимо)
var _segment_sides: Array[String] = []  # Текущая сторона для каждого сегмента
var _side_change_timers: Array[float] = []  # Таймеры до следующей смены стороны
var _side_change_intervals: Array[float] = []  # Интервалы смены для каждого сегмента
const SIDES: Array[String] = ["front", "back", "left", "right", "top", "bottom"]

func _ready() -> void:
	if multimesh_instance == null:
		multimesh_instance = MultiMeshInstance2D.new()
		multimesh_instance.name = "MultiMeshInstance2D"
		multimesh_instance.z_index = -10  # Стена на заднем плане
		add_child(multimesh_instance)
	
	_multimesh = MultiMesh.new()
	_multimesh.transform_format = MultiMesh.TRANSFORM_2D
	_multimesh.use_colors = true
	_multimesh.instance_count = 0
	
	# Создаём базовый квадрат для сегмента программно
	var array_mesh = ArrayMesh.new()
	var arrays = []
	arrays.resize(Mesh.ARRAY_MAX)
	
	var half_size: float = SEGMENT_SIZE * 0.5
	var vertices = PackedVector3Array([
		Vector3(-half_size, -half_size, 0),
		Vector3(half_size, -half_size, 0),
		Vector3(half_size, half_size, 0),
		Vector3(-half_size, half_size, 0)
	])
	var indices = PackedInt32Array([0, 1, 2, 0, 2, 3])
	var uvs = PackedVector2Array([
		Vector2(0, 0),
		Vector2(1, 0),
		Vector2(1, 1),
		Vector2(0, 1)
	])
	
	arrays[Mesh.ARRAY_VERTEX] = vertices
	arrays[Mesh.ARRAY_INDEX] = indices
	arrays[Mesh.ARRAY_TEX_UV] = uvs
	
	array_mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, arrays)
	_multimesh.mesh = array_mesh
	
	multimesh_instance.multimesh = _multimesh

func setup(data: WallData, side: String, purchases_enabled: bool = false) -> void:
	wall_data = data
	side_id = side
	allow_purchases = purchases_enabled

func update_visible_area(min_x: int, max_x: int, min_y: int, max_y: int) -> void:
	visible_min_x = min_x
	visible_max_x = max_x
	visible_min_y = min_y
	visible_max_y = max_y
	
	# Вычисляем количество видимых сегментов
	var width: int = max_x - min_x + 1
	var height: int = max_y - min_y + 1
	var total_segments: int = width * height
	
	# Сохраняем текущие стороны существующих сегментов (чтобы не терять состояние)
	var old_sides: Dictionary = {}  # segment_id -> side
	var old_timers: Dictionary = {}  # segment_id -> timer
	var old_intervals: Dictionary = {}  # segment_id -> interval
	
	for i in range(_segment_ids.size()):
		if i < _segment_sides.size():
			old_sides[_segment_ids[i]] = _segment_sides[i]
		if i < _side_change_timers.size():
			old_timers[_segment_ids[i]] = _side_change_timers[i]
		if i < _side_change_intervals.size():
			old_intervals[_segment_ids[i]] = _side_change_intervals[i]
	
	# Обновляем MultiMesh
	_multimesh.instance_count = total_segments
	
	# Очищаем массивы
	_transforms.clear()
	_segment_ids.clear()
	_breathing_params.clear()
	_segment_sides.clear()
	_side_change_timers.clear()
	_side_change_intervals.clear()
	
	_transforms.resize(total_segments)
	_segment_ids.resize(total_segments)
	_breathing_params.resize(total_segments)
	_segment_sides.resize(total_segments)
	_side_change_timers.resize(total_segments)
	_side_change_intervals.resize(total_segments)
	
	# Заполняем трансформы и данные
	var idx: int = 0
	for y in range(min_y, max_y + 1):
		for x in range(min_x, max_x + 1):
			var segment_id: String = "%d_%d" % [x, y]
			var pos: Vector2 = Vector2(x * SEGMENT_SIZE, y * SEGMENT_SIZE)
			
			# Генерируем РАНДОМНЫЕ параметры на основе segment_id
			var seed_hash: int = hash(segment_id)
			var rng = RandomNumberGenerator.new()
			rng.seed = seed_hash
			
			# Восстанавливаем сторону из старого состояния или создаём новую
			var current_side: String
			if old_sides.has(segment_id):
				# Сохраняем текущую сторону сегмента
				current_side = old_sides[segment_id]
				_side_change_timers[idx] = old_timers.get(segment_id, 0.0)
				_side_change_intervals[idx] = old_intervals.get(segment_id, rng.randf_range(30.0, 90.0))
			else:
				# Новый сегмент - случайная начальная сторона
				current_side = SIDES[rng.randi() % SIDES.size()]
				var change_interval: float = rng.randf_range(30.0, 90.0)
				_side_change_intervals[idx] = change_interval
				_side_change_timers[idx] = rng.randf_range(0.0, change_interval * 0.3)  # Случайный старт
			
			_segment_sides[idx] = current_side
			
			# Получаем данные сегмента для текущей стороны
			var seg_data: Dictionary = wall_data.get_segment(segment_id)
			var face_data: Dictionary = wall_data.get_face_data(segment_id, current_side)
			
			# Цвет сегмента по текущей стороне (визуализация смены сторон)
			var color: Color = _get_segment_color_by_side(current_side, face_data)
			
			# Базовый трансформ (без дыхания)
			var transform: Transform2D = Transform2D.IDENTITY
			transform.origin = pos
			
			_transforms[idx] = transform
			_segment_ids[idx] = segment_id
			
			# Генерируем РАНДОМНЫЕ параметры дыхания для каждого сегмента
			_breathing_params[idx] = {
				"phase": rng.randf() * TAU,  # Случайная начальная фаза
				"speed_factor": rng.randf_range(0.6, 1.4),  # Случайная скорость
				"amplitude_x": rng.randf_range(0.3, 0.8) * BASE_BREATHING_AMPLITUDE,  # Случайная амплитуда по X
				"amplitude_y": rng.randf_range(0.5, 1.2) * BASE_BREATHING_AMPLITUDE,  # Случайная амплитуда по Y
				"offset_x": rng.randf_range(-0.5, 0.5),  # Случайное смещение фазы по X
				"offset_y": rng.randf_range(-0.5, 0.5)   # Случайное смещение фазы по Y
			}
			
			# Применяем к MultiMesh
			_multimesh.set_instance_transform_2d(idx, transform)
			_multimesh.set_instance_color(idx, color)
			
			idx += 1

func _process(delta: float) -> void:
	# Обрабатываем смену сторон сегментов (независимо для каждого)
	_process_side_changes(delta)
	
	if not GameState.wall_breathing_enabled:
		# Если дыхание выключено, применяем базовые трансформы без смещения
		for i in range(_multimesh.instance_count):
			_multimesh.set_instance_transform_2d(i, _transforms[i])
		return
	
	# Глобальное время для дыхания
	_breathing_time += delta
	
	# Применяем НЕЗАВИСИМОЕ дыхание к каждому сегменту
	for i in range(_multimesh.instance_count):
		if i >= _breathing_params.size():
			continue
		
		var base_transform: Transform2D = _transforms[i]
		var params: Dictionary = _breathing_params[i]
		
		# Вычисляем независимое движение для каждого сегмента
		var phase_x: float = _breathing_time * BASE_BREATHING_SPEED * params.speed_factor + params.phase + params.offset_x
		var phase_y: float = _breathing_time * BASE_BREATHING_SPEED * params.speed_factor + params.phase + params.offset_y
		
		# Рандомное движение по осям X и Y независимо
		var offset_x: float = sin(phase_x) * params.amplitude_x
		var offset_y: float = cos(phase_y) * params.amplitude_y
		
		var random_offset: Vector2 = Vector2(offset_x, offset_y)
		
		var final_transform: Transform2D = base_transform
		final_transform.origin += random_offset
		
		_multimesh.set_instance_transform_2d(i, final_transform)

func _process_side_changes(delta: float) -> void:
	# Обрабатываем смену сторон для каждого сегмента независимо
	for i in range(_multimesh.instance_count):
		if i >= _side_change_timers.size() or i >= _segment_sides.size():
			continue
		
		# Увеличиваем таймер
		_side_change_timers[i] += delta
		
		# Проверяем, пора ли менять сторону
		if _side_change_timers[i] >= _side_change_intervals[i]:
			# Меняем сторону на случайную другую
			var current_side: String = _segment_sides[i]
			var new_side: String = current_side
			
			# Выбираем случайную сторону, отличную от текущей
			var available_sides: Array[String] = []
			for side in SIDES:
				if side != current_side:
					available_sides.append(side)
			
			if available_sides.size() > 0:
				var seed_hash: int = hash(_segment_ids[i] + str(Time.get_ticks_msec()))
				var rng = RandomNumberGenerator.new()
				rng.seed = seed_hash
				new_side = available_sides[rng.randi() % available_sides.size()]
			
			_segment_sides[i] = new_side
			
			# Сбрасываем таймер и задаём новый интервал
			var segment_id: String = _segment_ids[i]
			var seed_hash: int = hash(segment_id)
			var rng = RandomNumberGenerator.new()
			rng.seed = seed_hash
			_side_change_intervals[i] = rng.randf_range(30.0, 90.0)
			_side_change_timers[i] = 0.0
			
			# Обновляем цвет сегмента по новой стороне
			var face_data: Dictionary = wall_data.get_face_data(segment_id, new_side)
			var color: Color = _get_segment_color_by_side(new_side, face_data)
			_multimesh.set_instance_color(i, color)

# Обновление конкретного сегмента после покупки
func update_segment(segment_id: String) -> void:
	if wall_data == null or _multimesh == null:
		return
	
	# Находим индекс сегмента в массиве
	var idx: int = -1
	for i in range(_segment_ids.size()):
		if _segment_ids[i] == segment_id:
			idx = i
			break
	
	if idx < 0 or idx >= _multimesh.instance_count:
		return
	
	# Обновляем цвет сегмента по текущей стороне сегмента
	var current_side: String = _segment_sides[idx] if idx < _segment_sides.size() else side_id
	var face_data: Dictionary = wall_data.get_face_data(segment_id, current_side)
	var color: Color = _get_segment_color_by_side(current_side, face_data)
	_multimesh.set_instance_color(idx, color)

func _get_segment_color_by_side(segment_side: String, face_data: Dictionary) -> Color:
	# Базовый цвет по стороне сегмента (не по side_id стены!)
	var base_color: Color = _get_side_color(segment_side)
	
	# Если куплено, подмешиваем зелёный
	var owner: String = str(face_data.get("owner", ""))
	if owner != "":
		var owned_color: Color = Color(0.1, 0.8, 0.2)
		base_color = base_color.lerp(owned_color, 0.3)
	
	return base_color

func _get_side_color(segment_side: String) -> Color:
	# ВРЕМЕННАЯ ВИЗУАЛИЗАЦИЯ: разные оттенки бирюзового для каждой стороны
	match segment_side:
		"front":
			return Color(0.0, 0.8, 0.7)  # Яркий бирюзовый
		"back":
			return Color(0.0, 0.5, 0.5)  # Тёмно-бирюзовый
		"left":
			return Color(0.2, 0.7, 0.6)  # Зелёно-бирюзовый
		"right":
			return Color(0.1, 0.6, 0.8)  # Голубовато-бирюзовый
		"top":
			return Color(0.3, 0.9, 0.8)  # Светло-бирюзовый
		"bottom":
			return Color(0.0, 0.4, 0.6)  # Холодный сине-бирюзовый
		_:
			return Color(0.0, 0.8, 0.7)  # По умолчанию яркий бирюзовый

# Обработка клика по координатам (для CubeView)
func handle_click(global_pos: Vector2) -> Dictionary:
	if not allow_purchases or wall_data == null:
		return {}
	
	var local_pos: Vector2 = to_local(global_pos)
	
	# Вычисляем координаты сегмента
	var seg_x: int = int(floor(local_pos.x / SEGMENT_SIZE))
	var seg_y: int = int(floor(local_pos.y / SEGMENT_SIZE))
	var segment_id: String = "%d_%d" % [seg_x, seg_y]
	
	# Проверяем высотный гейт
	var seg_height: float = wall_data.get_segment_height(segment_id)
	if Engine.has_singleton("GameState"):
		var max_height: float = float(GameState.max_height_reached)
		if seg_height < max_height:
			return {}  # Сегмент выше достигнутой высоты
	
	# Возвращаем данные для покупки
	return {
		"segment_id": segment_id,
		"side": side_id,
		"price": wall_data.get_segment_price(segment_id),
		"height": seg_height
	}


--- FILE: D:\YandexDisk\Projects\Runner\Godot\wall\WallView.gd ---

extends Node2D
class_name WallView

@export var segment_scene: PackedScene = preload("res://wall/segment/WallSegment.tscn")
@export var segment_size: float = 48.0
@export var visible_cols: int = 8
@export var visible_rows: int = 6
@export var side_id: String = "front"

var wall_data: WallData = null
var origin_col: int = 0
var origin_row: int = 0

var _segments: Array[WallSegment] = []
var _cell_x: PackedInt32Array = PackedInt32Array()
var _cell_y: PackedInt32Array = PackedInt32Array()

func setup(data: WallData) -> void:
	wall_data = data
	_create_pool()
	_update_all_segments()

func set_origin(col: int, row: int) -> void:
	origin_col = col
	origin_row = row
	_update_all_segments()

func move_origin(delta_col: int, delta_row: int) -> void:
	origin_col += delta_col
	origin_row += delta_row
	_update_all_segments()

func handle_click_global(global_pos: Vector2, owner_id: int) -> void:
	if wall_data == null:
		return
	if owner_id == 0:
		return
	if _segments.is_empty():
		return
	var local: Vector2 = to_local(global_pos)
	if local.x < 0.0 or local.y < 0.0:
		return
	var col: int = int(floor(local.x / segment_size))
	var row: int = int(floor(local.y / segment_size))
	if col < 0 or col >= visible_cols or row < 0 or row >= visible_rows:
		return
	var world_x: int = origin_col + col
	var world_y: int = origin_row + row
	var ok: bool = wall_data.buy_cell(side_id, world_x, world_y, owner_id)
	if not ok:
		return
	var count: int = _segments.size()
	for i in count:
		if i >= _cell_x.size() or i >= _cell_y.size():
			break
		if _cell_x[i] == world_x and _cell_y[i] == world_y:
			var seg: WallSegment = _segments[i]
			if seg != null:
				seg.apply_state(world_x, world_y)
			break

func _create_pool() -> void:
	if wall_data == null:
		return
	if segment_scene == null:
		return
	if not _segments.is_empty():
		return
	var count: int = visible_cols * visible_rows
	_segments.clear()
	_segments.resize(count)
	_cell_x = PackedInt32Array()
	_cell_x.resize(count)
	_cell_y = PackedInt32Array()
	_cell_y.resize(count)
	var idx: int = 0
	for _row in visible_rows:
		for _col in visible_cols:
			var inst := segment_scene.instantiate()
			var seg: WallSegment = inst as WallSegment
			if seg == null:
				continue
			add_child(seg)
			seg.position = Vector2.ZERO
			seg.setup(side_id, wall_data)
			_segments[idx] = seg
			_cell_x[idx] = 0
			_cell_y[idx] = 0
			idx += 1

func _update_all_segments() -> void:
	if wall_data == null:
		return
	if _segments.is_empty():
		return
	var idx: int = 0
	var total: int = _segments.size()
	for row in visible_rows:
		for col in visible_cols:
			if idx >= total:
				return
			var seg: WallSegment = _segments[idx]
			if seg == null:
				idx += 1
				continue
			var world_x: int = origin_col + col
			var world_y: int = origin_row + row
			_cell_x[idx] = world_x
			_cell_y[idx] = world_y
			var local_pos := Vector2(
				float(col) * segment_size + segment_size * 0.5,
				float(row) * segment_size + segment_size * 0.5
			)
			seg.position = local_pos
			seg.apply_state(world_x, world_y)
			idx += 1


